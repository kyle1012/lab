{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport { h } from 'preact';\nimport { UIPlugin } from '@uppy/core';\nimport getFileTypeExtension from '@uppy/utils/lib/getFileTypeExtension';\nimport mimeTypes from '@uppy/utils/lib/mimeTypes';\nimport isMobile from 'is-mobile';\nimport canvasToBlob from '@uppy/utils/lib/canvasToBlob';\nimport supportsMediaRecorder from './supportsMediaRecorder.js';\nimport CameraIcon from \"./CameraIcon.js\";\nimport CameraScreen from \"./CameraScreen.js\";\nimport PermissionsScreen from \"./PermissionsScreen.js\";\nconst packageJson = {\n  \"version\": \"3.2.1\"\n};\nimport locale from './locale.js';\n/**\n * Normalize a MIME type or file extension into a MIME type.\n *\n * @param {string} fileType - MIME type or a file extension prefixed with `.`.\n * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.\n */\n\nfunction toMimeType(fileType) {\n  if (fileType[0] === '.') {\n    return mimeTypes[fileType.slice(1)];\n  }\n  return fileType;\n}\n/**\n * Is this MIME type a video?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\nfunction isVideoMimeType(mimeType) {\n  return /^video\\/[^*]+$/.test(mimeType);\n}\n/**\n * Is this MIME type an image?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\nfunction isImageMimeType(mimeType) {\n  return /^image\\/[^*]+$/.test(mimeType);\n}\nfunction getMediaDevices() {\n  // bug in the compatibility data\n  // eslint-disable-next-line compat/compat\n  return navigator.mediaDevices;\n}\nfunction isModeAvailable(modes, mode) {\n  return modes.includes(mode);\n}\n/**\n * Webcam\n */\n\nvar _enableMirror = /*#__PURE__*/_classPrivateFieldLooseKey(\"enableMirror\");\nexport default class Webcam extends UIPlugin {\n  // enableMirror is used to toggle mirroring, for instance when discarding the video,\n  // while `opts.mirror` is used to remember the initial user setting\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _enableMirror, {\n      writable: true,\n      value: void 0\n    });\n    this.mediaDevices = getMediaDevices();\n    this.supportsUserMedia = !!this.mediaDevices; // eslint-disable-next-line no-restricted-globals\n\n    this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';\n    this.id = this.opts.id || 'Webcam';\n    this.type = 'acquirer';\n    this.capturedMediaFile = null;\n    this.icon = () => h(\"svg\", {\n      \"aria-hidden\": \"true\",\n      focusable: \"false\",\n      width: \"32\",\n      height: \"32\",\n      viewBox: \"0 0 32 32\"\n    }, h(\"g\", {\n      fill: \"none\",\n      fillRule: \"evenodd\"\n    }, h(\"rect\", {\n      className: \"uppy-ProviderIconBg\",\n      fill: \"#03BFEF\",\n      width: \"32\",\n      height: \"32\",\n      rx: \"16\"\n    }), h(\"path\", {\n      d: \"M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z\",\n      fill: \"#FFF\",\n      fillRule: \"nonzero\"\n    })));\n    this.defaultLocale = locale; // set default options\n\n    const defaultOptions = {\n      onBeforeSnapshot: () => Promise.resolve(),\n      countdown: false,\n      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],\n      mirror: true,\n      showVideoSourceDropdown: false,\n      facingMode: 'user',\n      // @TODO: remove in the next major\n      videoConstraints: undefined,\n      preferredImageMimeType: null,\n      preferredVideoMimeType: null,\n      showRecordingLength: false,\n      mobileNativeCamera: isMobile({\n        tablet: true\n      })\n    };\n    this.opts = {\n      ...defaultOptions,\n      ...opts\n    };\n    this.i18nInit();\n    this.title = this.i18n('pluginNameCamera');\n    _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = this.opts.mirror;\n    this.install = this.install.bind(this);\n    this.setPluginState = this.setPluginState.bind(this);\n    this.render = this.render.bind(this); // Camera controls\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.takeSnapshot = this.takeSnapshot.bind(this);\n    this.startRecording = this.startRecording.bind(this);\n    this.stopRecording = this.stopRecording.bind(this);\n    this.discardRecordedVideo = this.discardRecordedVideo.bind(this);\n    this.submit = this.submit.bind(this);\n    this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this);\n    this.focus = this.focus.bind(this);\n    this.changeVideoSource = this.changeVideoSource.bind(this);\n    this.webcamActive = false;\n    if (this.opts.countdown) {\n      this.opts.onBeforeSnapshot = this.oneTwoThreeSmile;\n    }\n    this.setPluginState({\n      hasCamera: false,\n      cameraReady: false,\n      cameraError: null,\n      recordingLengthSeconds: 0,\n      videoSources: [],\n      currentDeviceId: null\n    });\n  }\n  setOptions(newOpts) {\n    super.setOptions({\n      ...newOpts,\n      videoConstraints: {\n        // May be undefined but ... handles that\n        ...this.opts.videoConstraints,\n        ...(newOpts == null ? void 0 : newOpts.videoConstraints)\n      }\n    });\n  }\n  hasCameraCheck() {\n    if (!this.mediaDevices) {\n      return Promise.resolve(false);\n    }\n    return this.mediaDevices.enumerateDevices().then(devices => {\n      return devices.some(device => device.kind === 'videoinput');\n    });\n  }\n  isAudioOnly() {\n    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';\n  }\n  getConstraints(deviceId) {\n    if (deviceId === void 0) {\n      deviceId = null;\n    }\n    const acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;\n    const acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);\n    const videoConstraints = {\n      ...(this.opts.videoConstraints || {\n        facingMode: this.opts.facingMode\n      }),\n      // facingMode takes precedence over deviceId, and not needed\n      // when specific device is selected\n      ...(deviceId ? {\n        deviceId,\n        facingMode: null\n      } : {})\n    };\n    return {\n      audio: acceptsAudio,\n      video: acceptsVideo ? videoConstraints : false\n    };\n  } // eslint-disable-next-line consistent-return\n\n  start(options) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (!this.supportsUserMedia) {\n      return Promise.reject(new Error('Webcam access not supported'));\n    }\n    this.webcamActive = true;\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n    const constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);\n    this.hasCameraCheck().then(hasCamera => {\n      this.setPluginState({\n        hasCamera\n      }); // ask user for access to their camera\n\n      return this.mediaDevices.getUserMedia(constraints).then(stream => {\n        this.stream = stream;\n        let currentDeviceId = null;\n        const tracks = this.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();\n        if (!options || !options.deviceId) {\n          currentDeviceId = tracks[0].getSettings().deviceId;\n        } else {\n          tracks.forEach(track => {\n            if (track.getSettings().deviceId === options.deviceId) {\n              currentDeviceId = track.getSettings().deviceId;\n            }\n          });\n        } // Update the sources now, so we can access the names.\n\n        this.updateVideoSources();\n        this.setPluginState({\n          currentDeviceId,\n          cameraReady: true\n        });\n      }).catch(err => {\n        this.setPluginState({\n          cameraReady: false,\n          cameraError: err\n        });\n        this.uppy.info(err.message, 'error');\n      });\n    });\n  }\n  /**\n   * @returns {object}\n   */\n\n  getMediaRecorderOptions() {\n    const options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.\n    // If the browser doesn't support it, we'll fall back to the browser default instead.\n    // Safari doesn't have the `isTypeSupported` API.\n\n    if (MediaRecorder.isTypeSupported) {\n      const {\n        restrictions\n      } = this.uppy.opts;\n      let preferredVideoMimeTypes = [];\n      if (this.opts.preferredVideoMimeType) {\n        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];\n      } else if (restrictions.allowedFileTypes) {\n        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);\n      }\n      const filterSupportedTypes = candidateType => MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);\n      const acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);\n      if (acceptableMimeTypes.length > 0) {\n        // eslint-disable-next-line prefer-destructuring\n        options.mimeType = acceptableMimeTypes[0];\n      }\n    }\n    return options;\n  }\n  startRecording() {\n    // only used if supportsMediaRecorder() returned true\n    // eslint-disable-next-line compat/compat\n    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());\n    this.recordingChunks = [];\n    let stoppingBecauseOfMaxSize = false;\n    this.recorder.addEventListener('dataavailable', event => {\n      this.recordingChunks.push(event.data);\n      const {\n        restrictions\n      } = this.uppy.opts;\n      if (this.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {\n        const totalSize = this.recordingChunks.reduce((acc, chunk) => acc + chunk.size, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier\n\n        const averageChunkSize = (totalSize - this.recordingChunks[0].size) / (this.recordingChunks.length - 1);\n        const expectedEndChunkSize = averageChunkSize * 3;\n        const maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);\n        if (totalSize > maxSize) {\n          stoppingBecauseOfMaxSize = true;\n          this.uppy.info(this.i18n('recordingStoppedMaxSize'), 'warning', 4000);\n          this.stopRecording();\n        }\n      }\n    }); // use a \"time slice\" of 500ms: ondataavailable will be called each 500ms\n    // smaller time slices mean we can more accurately check the max file size restriction\n\n    this.recorder.start(500);\n    if (this.opts.showRecordingLength) {\n      // Start the recordingLengthTimer if we are showing the recording length.\n      this.recordingLengthTimer = setInterval(() => {\n        const currentRecordingLength = this.getPluginState().recordingLengthSeconds;\n        this.setPluginState({\n          recordingLengthSeconds: currentRecordingLength + 1\n        });\n      }, 1000);\n    }\n    this.setPluginState({\n      isRecording: true\n    });\n  }\n  stopRecording() {\n    const stopped = new Promise(resolve => {\n      this.recorder.addEventListener('stop', () => {\n        resolve();\n      });\n      this.recorder.stop();\n      if (this.opts.showRecordingLength) {\n        // Stop the recordingLengthTimer if we are showing the recording length.\n        clearInterval(this.recordingLengthTimer);\n        this.setPluginState({\n          recordingLengthSeconds: 0\n        });\n      }\n    });\n    return stopped.then(() => {\n      this.setPluginState({\n        isRecording: false\n      });\n      return this.getVideo();\n    }).then(file => {\n      try {\n        this.capturedMediaFile = file; // create object url for capture result preview\n\n        this.setPluginState({\n          // eslint-disable-next-line compat/compat\n          recordedVideo: URL.createObjectURL(file.data)\n        });\n        _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = false;\n      } catch (err) {\n        // Logging the error, exept restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }).then(() => {\n      this.recordingChunks = null;\n      this.recorder = null;\n    }, error => {\n      this.recordingChunks = null;\n      this.recorder = null;\n      throw error;\n    });\n  }\n  discardRecordedVideo() {\n    this.setPluginState({\n      recordedVideo: null\n    });\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n    this.capturedMediaFile = null;\n  }\n  submit() {\n    try {\n      if (this.capturedMediaFile) {\n        this.uppy.addFile(this.capturedMediaFile);\n      }\n    } catch (err) {\n      // Logging the error, exept restrictions, which is handled in Core\n      if (!err.isRestriction) {\n        this.uppy.log(err, 'error');\n      }\n    }\n  }\n  async stop() {\n    if (this.stream) {\n      const audioTracks = this.stream.getAudioTracks();\n      const videoTracks = this.stream.getVideoTracks();\n      audioTracks.concat(videoTracks).forEach(track => track.stop());\n    }\n    if (this.recorder) {\n      await new Promise(resolve => {\n        this.recorder.addEventListener('stop', resolve, {\n          once: true\n        });\n        this.recorder.stop();\n        if (this.opts.showRecordingLength) {\n          clearInterval(this.recordingLengthTimer);\n        }\n      });\n    }\n    this.recordingChunks = null;\n    this.recorder = null;\n    this.webcamActive = false;\n    this.stream = null;\n    this.setPluginState({\n      recordedVideo: null,\n      isRecording: false,\n      recordingLengthSeconds: 0\n    });\n  }\n  getVideoElement() {\n    return this.el.querySelector('.uppy-Webcam-video');\n  }\n  oneTwoThreeSmile() {\n    return new Promise((resolve, reject) => {\n      let count = this.opts.countdown; // eslint-disable-next-line consistent-return\n\n      const countDown = setInterval(() => {\n        if (!this.webcamActive) {\n          clearInterval(countDown);\n          this.captureInProgress = false;\n          return reject(new Error('Webcam is not active'));\n        }\n        if (count > 0) {\n          this.uppy.info(`${count}...`, 'warning', 800);\n          count--;\n        } else {\n          clearInterval(countDown);\n          this.uppy.info(this.i18n('smile'), 'success', 1500);\n          setTimeout(() => resolve(), 1500);\n        }\n      }, 1000);\n    });\n  }\n  takeSnapshot() {\n    if (this.captureInProgress) return;\n    this.captureInProgress = true;\n    this.opts.onBeforeSnapshot().catch(err => {\n      const message = typeof err === 'object' ? err.message : err;\n      this.uppy.info(message, 'error', 5000);\n      return Promise.reject(new Error(`onBeforeSnapshot: ${message}`));\n    }).then(() => {\n      return this.getImage();\n    }).then(tagFile => {\n      this.captureInProgress = false;\n      try {\n        this.uppy.addFile(tagFile);\n      } catch (err) {\n        // Logging the error, except restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }, error => {\n      this.captureInProgress = false;\n      throw error;\n    });\n  }\n  getImage() {\n    const video = this.getVideoElement();\n    if (!video) {\n      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));\n    }\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0);\n    const {\n      restrictions\n    } = this.uppy.opts;\n    let preferredImageMimeTypes = [];\n    if (this.opts.preferredImageMimeType) {\n      preferredImageMimeTypes = [this.opts.preferredImageMimeType];\n    } else if (restrictions.allowedFileTypes) {\n      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);\n    }\n    const mimeType = preferredImageMimeTypes[0] || 'image/jpeg';\n    const ext = getFileTypeExtension(mimeType) || 'jpg';\n    const name = `cam-${Date.now()}.${ext}`;\n    return canvasToBlob(canvas, mimeType).then(blob => {\n      return {\n        source: this.id,\n        name,\n        data: new Blob([blob], {\n          type: mimeType\n        }),\n        type: mimeType\n      };\n    });\n  }\n  getVideo() {\n    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)\n    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'\n    // attribute in order to determine the correct MIME type.\n    const mimeType = this.recordingChunks.find(blob => {\n      var _blob$type;\n      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;\n    }).type;\n    const fileExtension = getFileTypeExtension(mimeType);\n    if (!fileExtension) {\n      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type \"${mimeType}\"`));\n    }\n    const name = `webcam-${Date.now()}.${fileExtension}`;\n    const blob = new Blob(this.recordingChunks, {\n      type: mimeType\n    });\n    const file = {\n      source: this.id,\n      name,\n      data: new Blob([blob], {\n        type: mimeType\n      }),\n      type: mimeType\n    };\n    return Promise.resolve(file);\n  }\n  focus() {\n    if (!this.opts.countdown) return;\n    setTimeout(() => {\n      this.uppy.info(this.i18n('smile'), 'success', 1500);\n    }, 1000);\n  }\n  changeVideoSource(deviceId) {\n    this.stop();\n    this.start({\n      deviceId\n    });\n  }\n  updateVideoSources() {\n    this.mediaDevices.enumerateDevices().then(devices => {\n      this.setPluginState({\n        videoSources: devices.filter(device => device.kind === 'videoinput')\n      });\n    });\n  }\n  render() {\n    if (!this.webcamActive) {\n      this.start();\n    }\n    const webcamState = this.getPluginState();\n    if (!webcamState.cameraReady || !webcamState.hasCamera) {\n      return h(PermissionsScreen, {\n        icon: CameraIcon,\n        i18n: this.i18n,\n        hasCamera: webcamState.hasCamera\n      });\n    }\n    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading\n    , _extends({}, webcamState, {\n      onChangeVideoSource: this.changeVideoSource,\n      onSnapshot: this.takeSnapshot,\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onDiscardRecordedVideo: this.discardRecordedVideo,\n      onSubmit: this.submit,\n      onFocus: this.focus,\n      onStop: this.stop,\n      i18n: this.i18n,\n      modes: this.opts.modes,\n      showRecordingLength: this.opts.showRecordingLength,\n      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,\n      supportsRecording: supportsMediaRecorder(),\n      recording: webcamState.isRecording,\n      mirror: _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror],\n      src: this.stream\n    }));\n  }\n  install() {\n    const {\n      mobileNativeCamera,\n      modes,\n      facingMode,\n      videoConstraints\n    } = this.opts;\n    const {\n      target\n    } = this.opts;\n    if (mobileNativeCamera && target) {\n      var _this$getTargetPlugin;\n      (_this$getTargetPlugin = this.getTargetPlugin(target)) == null ? void 0 : _this$getTargetPlugin.setOptions({\n        showNativeVideoCameraButton: isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'video-audio'),\n        showNativePhotoCameraButton: isModeAvailable(modes, 'picture'),\n        nativeCameraFacingMode: (videoConstraints == null ? void 0 : videoConstraints.facingMode) || facingMode\n      });\n      return;\n    }\n    this.setPluginState({\n      cameraReady: false,\n      recordingLengthSeconds: 0\n    });\n    if (target) {\n      this.mount(target, this);\n    }\n    if (this.mediaDevices) {\n      this.updateVideoSources();\n      this.mediaDevices.ondevicechange = () => {\n        this.updateVideoSources();\n        if (this.stream) {\n          let restartStream = true;\n          const {\n            videoSources,\n            currentDeviceId\n          } = this.getPluginState();\n          videoSources.forEach(videoSource => {\n            if (currentDeviceId === videoSource.deviceId) {\n              restartStream = false;\n            }\n          });\n          if (restartStream) {\n            this.stop();\n            this.start();\n          }\n        }\n      };\n    }\n  }\n  uninstall() {\n    this.stop();\n    this.unmount();\n  }\n  onUnmount() {\n    this.stop();\n  }\n}\nWebcam.VERSION = packageJson.version;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_classPrivateFieldLooseBase","receiver","privateKey","TypeError","id","_classPrivateFieldLooseKey","name","h","UIPlugin","getFileTypeExtension","mimeTypes","isMobile","canvasToBlob","supportsMediaRecorder","CameraIcon","CameraScreen","PermissionsScreen","packageJson","locale","toMimeType","fileType","slice","isVideoMimeType","mimeType","test","isImageMimeType","getMediaDevices","navigator","mediaDevices","isModeAvailable","modes","mode","includes","_enableMirror","Webcam","constructor","uppy","opts","defineProperty","writable","value","supportsUserMedia","protocol","location","match","type","capturedMediaFile","icon","focusable","width","height","viewBox","fill","fillRule","className","rx","d","defaultLocale","defaultOptions","onBeforeSnapshot","Promise","resolve","countdown","mirror","showVideoSourceDropdown","facingMode","videoConstraints","undefined","preferredImageMimeType","preferredVideoMimeType","showRecordingLength","mobileNativeCamera","tablet","i18nInit","title","i18n","install","setPluginState","render","start","stop","takeSnapshot","startRecording","stopRecording","discardRecordedVideo","submit","oneTwoThreeSmile","focus","changeVideoSource","webcamActive","hasCamera","cameraReady","cameraError","recordingLengthSeconds","videoSources","currentDeviceId","setOptions","newOpts","hasCameraCheck","enumerateDevices","then","devices","some","device","kind","isAudioOnly","getConstraints","deviceId","acceptsAudio","indexOf","acceptsVideo","audio","video","options","reject","Error","constraints","getUserMedia","stream","tracks","getAudioTracks","getVideoTracks","getSettings","forEach","track","updateVideoSources","catch","err","info","message","getMediaRecorderOptions","MediaRecorder","isTypeSupported","restrictions","preferredVideoMimeTypes","allowedFileTypes","map","filter","filterSupportedTypes","candidateType","acceptableMimeTypes","recorder","recordingChunks","stoppingBecauseOfMaxSize","addEventListener","event","push","data","maxFileSize","totalSize","reduce","acc","chunk","size","averageChunkSize","expectedEndChunkSize","maxSize","Math","max","recordingLengthTimer","setInterval","currentRecordingLength","getPluginState","isRecording","stopped","clearInterval","getVideo","file","recordedVideo","URL","createObjectURL","isRestriction","log","error","addFile","audioTracks","videoTracks","concat","once","getVideoElement","el","querySelector","count","countDown","captureInProgress","setTimeout","getImage","tagFile","videoWidth","videoHeight","canvas","document","createElement","ctx","getContext","drawImage","preferredImageMimeTypes","ext","Date","now","blob","Blob","find","_blob$type","fileExtension","webcamState","onChangeVideoSource","onSnapshot","onStartRecording","onStopRecording","onDiscardRecordedVideo","onSubmit","onFocus","onStop","supportsRecording","recording","src","_this$getTargetPlugin","getTargetPlugin","showNativeVideoCameraButton","showNativePhotoCameraButton","nativeCameraFacingMode","mount","ondevicechange","restartStream","videoSource","uninstall","unmount","onUnmount","VERSION","version"],"sources":["/lab/node_modules/@uppy/webcam/lib/Webcam.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\n\nvar id = 0;\n\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\n\nimport { h } from 'preact';\nimport { UIPlugin } from '@uppy/core';\nimport getFileTypeExtension from '@uppy/utils/lib/getFileTypeExtension';\nimport mimeTypes from '@uppy/utils/lib/mimeTypes';\nimport isMobile from 'is-mobile';\nimport canvasToBlob from '@uppy/utils/lib/canvasToBlob';\nimport supportsMediaRecorder from './supportsMediaRecorder.js';\nimport CameraIcon from \"./CameraIcon.js\";\nimport CameraScreen from \"./CameraScreen.js\";\nimport PermissionsScreen from \"./PermissionsScreen.js\";\nconst packageJson = {\n  \"version\": \"3.2.1\"\n};\nimport locale from './locale.js';\n/**\n * Normalize a MIME type or file extension into a MIME type.\n *\n * @param {string} fileType - MIME type or a file extension prefixed with `.`.\n * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.\n */\n\nfunction toMimeType(fileType) {\n  if (fileType[0] === '.') {\n    return mimeTypes[fileType.slice(1)];\n  }\n\n  return fileType;\n}\n/**\n * Is this MIME type a video?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isVideoMimeType(mimeType) {\n  return /^video\\/[^*]+$/.test(mimeType);\n}\n/**\n * Is this MIME type an image?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isImageMimeType(mimeType) {\n  return /^image\\/[^*]+$/.test(mimeType);\n}\n\nfunction getMediaDevices() {\n  // bug in the compatibility data\n  // eslint-disable-next-line compat/compat\n  return navigator.mediaDevices;\n}\n\nfunction isModeAvailable(modes, mode) {\n  return modes.includes(mode);\n}\n/**\n * Webcam\n */\n\n\nvar _enableMirror = /*#__PURE__*/_classPrivateFieldLooseKey(\"enableMirror\");\n\nexport default class Webcam extends UIPlugin {\n  // enableMirror is used to toggle mirroring, for instance when discarding the video,\n  // while `opts.mirror` is used to remember the initial user setting\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _enableMirror, {\n      writable: true,\n      value: void 0\n    });\n    this.mediaDevices = getMediaDevices();\n    this.supportsUserMedia = !!this.mediaDevices; // eslint-disable-next-line no-restricted-globals\n\n    this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';\n    this.id = this.opts.id || 'Webcam';\n    this.type = 'acquirer';\n    this.capturedMediaFile = null;\n\n    this.icon = () => h(\"svg\", {\n      \"aria-hidden\": \"true\",\n      focusable: \"false\",\n      width: \"32\",\n      height: \"32\",\n      viewBox: \"0 0 32 32\"\n    }, h(\"g\", {\n      fill: \"none\",\n      fillRule: \"evenodd\"\n    }, h(\"rect\", {\n      className: \"uppy-ProviderIconBg\",\n      fill: \"#03BFEF\",\n      width: \"32\",\n      height: \"32\",\n      rx: \"16\"\n    }), h(\"path\", {\n      d: \"M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z\",\n      fill: \"#FFF\",\n      fillRule: \"nonzero\"\n    })));\n\n    this.defaultLocale = locale; // set default options\n\n    const defaultOptions = {\n      onBeforeSnapshot: () => Promise.resolve(),\n      countdown: false,\n      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],\n      mirror: true,\n      showVideoSourceDropdown: false,\n      facingMode: 'user',\n      // @TODO: remove in the next major\n      videoConstraints: undefined,\n      preferredImageMimeType: null,\n      preferredVideoMimeType: null,\n      showRecordingLength: false,\n      mobileNativeCamera: isMobile({\n        tablet: true\n      })\n    };\n    this.opts = { ...defaultOptions,\n      ...opts\n    };\n    this.i18nInit();\n    this.title = this.i18n('pluginNameCamera');\n    _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = this.opts.mirror;\n    this.install = this.install.bind(this);\n    this.setPluginState = this.setPluginState.bind(this);\n    this.render = this.render.bind(this); // Camera controls\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.takeSnapshot = this.takeSnapshot.bind(this);\n    this.startRecording = this.startRecording.bind(this);\n    this.stopRecording = this.stopRecording.bind(this);\n    this.discardRecordedVideo = this.discardRecordedVideo.bind(this);\n    this.submit = this.submit.bind(this);\n    this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this);\n    this.focus = this.focus.bind(this);\n    this.changeVideoSource = this.changeVideoSource.bind(this);\n    this.webcamActive = false;\n\n    if (this.opts.countdown) {\n      this.opts.onBeforeSnapshot = this.oneTwoThreeSmile;\n    }\n\n    this.setPluginState({\n      hasCamera: false,\n      cameraReady: false,\n      cameraError: null,\n      recordingLengthSeconds: 0,\n      videoSources: [],\n      currentDeviceId: null\n    });\n  }\n\n  setOptions(newOpts) {\n    super.setOptions({ ...newOpts,\n      videoConstraints: { // May be undefined but ... handles that\n        ...this.opts.videoConstraints,\n        ...(newOpts == null ? void 0 : newOpts.videoConstraints)\n      }\n    });\n  }\n\n  hasCameraCheck() {\n    if (!this.mediaDevices) {\n      return Promise.resolve(false);\n    }\n\n    return this.mediaDevices.enumerateDevices().then(devices => {\n      return devices.some(device => device.kind === 'videoinput');\n    });\n  }\n\n  isAudioOnly() {\n    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';\n  }\n\n  getConstraints(deviceId) {\n    if (deviceId === void 0) {\n      deviceId = null;\n    }\n\n    const acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;\n    const acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);\n    const videoConstraints = { ...(this.opts.videoConstraints || {\n        facingMode: this.opts.facingMode\n      }),\n      // facingMode takes precedence over deviceId, and not needed\n      // when specific device is selected\n      ...(deviceId ? {\n        deviceId,\n        facingMode: null\n      } : {})\n    };\n    return {\n      audio: acceptsAudio,\n      video: acceptsVideo ? videoConstraints : false\n    };\n  } // eslint-disable-next-line consistent-return\n\n\n  start(options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (!this.supportsUserMedia) {\n      return Promise.reject(new Error('Webcam access not supported'));\n    }\n\n    this.webcamActive = true;\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    const constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);\n    this.hasCameraCheck().then(hasCamera => {\n      this.setPluginState({\n        hasCamera\n      }); // ask user for access to their camera\n\n      return this.mediaDevices.getUserMedia(constraints).then(stream => {\n        this.stream = stream;\n        let currentDeviceId = null;\n        const tracks = this.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();\n\n        if (!options || !options.deviceId) {\n          currentDeviceId = tracks[0].getSettings().deviceId;\n        } else {\n          tracks.forEach(track => {\n            if (track.getSettings().deviceId === options.deviceId) {\n              currentDeviceId = track.getSettings().deviceId;\n            }\n          });\n        } // Update the sources now, so we can access the names.\n\n\n        this.updateVideoSources();\n        this.setPluginState({\n          currentDeviceId,\n          cameraReady: true\n        });\n      }).catch(err => {\n        this.setPluginState({\n          cameraReady: false,\n          cameraError: err\n        });\n        this.uppy.info(err.message, 'error');\n      });\n    });\n  }\n  /**\n   * @returns {object}\n   */\n\n\n  getMediaRecorderOptions() {\n    const options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.\n    // If the browser doesn't support it, we'll fall back to the browser default instead.\n    // Safari doesn't have the `isTypeSupported` API.\n\n    if (MediaRecorder.isTypeSupported) {\n      const {\n        restrictions\n      } = this.uppy.opts;\n      let preferredVideoMimeTypes = [];\n\n      if (this.opts.preferredVideoMimeType) {\n        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];\n      } else if (restrictions.allowedFileTypes) {\n        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);\n      }\n\n      const filterSupportedTypes = candidateType => MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);\n\n      const acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);\n\n      if (acceptableMimeTypes.length > 0) {\n        // eslint-disable-next-line prefer-destructuring\n        options.mimeType = acceptableMimeTypes[0];\n      }\n    }\n\n    return options;\n  }\n\n  startRecording() {\n    // only used if supportsMediaRecorder() returned true\n    // eslint-disable-next-line compat/compat\n    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());\n    this.recordingChunks = [];\n    let stoppingBecauseOfMaxSize = false;\n    this.recorder.addEventListener('dataavailable', event => {\n      this.recordingChunks.push(event.data);\n      const {\n        restrictions\n      } = this.uppy.opts;\n\n      if (this.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {\n        const totalSize = this.recordingChunks.reduce((acc, chunk) => acc + chunk.size, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier\n\n        const averageChunkSize = (totalSize - this.recordingChunks[0].size) / (this.recordingChunks.length - 1);\n        const expectedEndChunkSize = averageChunkSize * 3;\n        const maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);\n\n        if (totalSize > maxSize) {\n          stoppingBecauseOfMaxSize = true;\n          this.uppy.info(this.i18n('recordingStoppedMaxSize'), 'warning', 4000);\n          this.stopRecording();\n        }\n      }\n    }); // use a \"time slice\" of 500ms: ondataavailable will be called each 500ms\n    // smaller time slices mean we can more accurately check the max file size restriction\n\n    this.recorder.start(500);\n\n    if (this.opts.showRecordingLength) {\n      // Start the recordingLengthTimer if we are showing the recording length.\n      this.recordingLengthTimer = setInterval(() => {\n        const currentRecordingLength = this.getPluginState().recordingLengthSeconds;\n        this.setPluginState({\n          recordingLengthSeconds: currentRecordingLength + 1\n        });\n      }, 1000);\n    }\n\n    this.setPluginState({\n      isRecording: true\n    });\n  }\n\n  stopRecording() {\n    const stopped = new Promise(resolve => {\n      this.recorder.addEventListener('stop', () => {\n        resolve();\n      });\n      this.recorder.stop();\n\n      if (this.opts.showRecordingLength) {\n        // Stop the recordingLengthTimer if we are showing the recording length.\n        clearInterval(this.recordingLengthTimer);\n        this.setPluginState({\n          recordingLengthSeconds: 0\n        });\n      }\n    });\n    return stopped.then(() => {\n      this.setPluginState({\n        isRecording: false\n      });\n      return this.getVideo();\n    }).then(file => {\n      try {\n        this.capturedMediaFile = file; // create object url for capture result preview\n\n        this.setPluginState({\n          // eslint-disable-next-line compat/compat\n          recordedVideo: URL.createObjectURL(file.data)\n        });\n        _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = false;\n      } catch (err) {\n        // Logging the error, exept restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }).then(() => {\n      this.recordingChunks = null;\n      this.recorder = null;\n    }, error => {\n      this.recordingChunks = null;\n      this.recorder = null;\n      throw error;\n    });\n  }\n\n  discardRecordedVideo() {\n    this.setPluginState({\n      recordedVideo: null\n    });\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    this.capturedMediaFile = null;\n  }\n\n  submit() {\n    try {\n      if (this.capturedMediaFile) {\n        this.uppy.addFile(this.capturedMediaFile);\n      }\n    } catch (err) {\n      // Logging the error, exept restrictions, which is handled in Core\n      if (!err.isRestriction) {\n        this.uppy.log(err, 'error');\n      }\n    }\n  }\n\n  async stop() {\n    if (this.stream) {\n      const audioTracks = this.stream.getAudioTracks();\n      const videoTracks = this.stream.getVideoTracks();\n      audioTracks.concat(videoTracks).forEach(track => track.stop());\n    }\n\n    if (this.recorder) {\n      await new Promise(resolve => {\n        this.recorder.addEventListener('stop', resolve, {\n          once: true\n        });\n        this.recorder.stop();\n\n        if (this.opts.showRecordingLength) {\n          clearInterval(this.recordingLengthTimer);\n        }\n      });\n    }\n\n    this.recordingChunks = null;\n    this.recorder = null;\n    this.webcamActive = false;\n    this.stream = null;\n    this.setPluginState({\n      recordedVideo: null,\n      isRecording: false,\n      recordingLengthSeconds: 0\n    });\n  }\n\n  getVideoElement() {\n    return this.el.querySelector('.uppy-Webcam-video');\n  }\n\n  oneTwoThreeSmile() {\n    return new Promise((resolve, reject) => {\n      let count = this.opts.countdown; // eslint-disable-next-line consistent-return\n\n      const countDown = setInterval(() => {\n        if (!this.webcamActive) {\n          clearInterval(countDown);\n          this.captureInProgress = false;\n          return reject(new Error('Webcam is not active'));\n        }\n\n        if (count > 0) {\n          this.uppy.info(`${count}...`, 'warning', 800);\n          count--;\n        } else {\n          clearInterval(countDown);\n          this.uppy.info(this.i18n('smile'), 'success', 1500);\n          setTimeout(() => resolve(), 1500);\n        }\n      }, 1000);\n    });\n  }\n\n  takeSnapshot() {\n    if (this.captureInProgress) return;\n    this.captureInProgress = true;\n    this.opts.onBeforeSnapshot().catch(err => {\n      const message = typeof err === 'object' ? err.message : err;\n      this.uppy.info(message, 'error', 5000);\n      return Promise.reject(new Error(`onBeforeSnapshot: ${message}`));\n    }).then(() => {\n      return this.getImage();\n    }).then(tagFile => {\n      this.captureInProgress = false;\n\n      try {\n        this.uppy.addFile(tagFile);\n      } catch (err) {\n        // Logging the error, except restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }, error => {\n      this.captureInProgress = false;\n      throw error;\n    });\n  }\n\n  getImage() {\n    const video = this.getVideoElement();\n\n    if (!video) {\n      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));\n    }\n\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0);\n    const {\n      restrictions\n    } = this.uppy.opts;\n    let preferredImageMimeTypes = [];\n\n    if (this.opts.preferredImageMimeType) {\n      preferredImageMimeTypes = [this.opts.preferredImageMimeType];\n    } else if (restrictions.allowedFileTypes) {\n      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);\n    }\n\n    const mimeType = preferredImageMimeTypes[0] || 'image/jpeg';\n    const ext = getFileTypeExtension(mimeType) || 'jpg';\n    const name = `cam-${Date.now()}.${ext}`;\n    return canvasToBlob(canvas, mimeType).then(blob => {\n      return {\n        source: this.id,\n        name,\n        data: new Blob([blob], {\n          type: mimeType\n        }),\n        type: mimeType\n      };\n    });\n  }\n\n  getVideo() {\n    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)\n    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'\n    // attribute in order to determine the correct MIME type.\n    const mimeType = this.recordingChunks.find(blob => {\n      var _blob$type;\n\n      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;\n    }).type;\n    const fileExtension = getFileTypeExtension(mimeType);\n\n    if (!fileExtension) {\n      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type \"${mimeType}\"`));\n    }\n\n    const name = `webcam-${Date.now()}.${fileExtension}`;\n    const blob = new Blob(this.recordingChunks, {\n      type: mimeType\n    });\n    const file = {\n      source: this.id,\n      name,\n      data: new Blob([blob], {\n        type: mimeType\n      }),\n      type: mimeType\n    };\n    return Promise.resolve(file);\n  }\n\n  focus() {\n    if (!this.opts.countdown) return;\n    setTimeout(() => {\n      this.uppy.info(this.i18n('smile'), 'success', 1500);\n    }, 1000);\n  }\n\n  changeVideoSource(deviceId) {\n    this.stop();\n    this.start({\n      deviceId\n    });\n  }\n\n  updateVideoSources() {\n    this.mediaDevices.enumerateDevices().then(devices => {\n      this.setPluginState({\n        videoSources: devices.filter(device => device.kind === 'videoinput')\n      });\n    });\n  }\n\n  render() {\n    if (!this.webcamActive) {\n      this.start();\n    }\n\n    const webcamState = this.getPluginState();\n\n    if (!webcamState.cameraReady || !webcamState.hasCamera) {\n      return h(PermissionsScreen, {\n        icon: CameraIcon,\n        i18n: this.i18n,\n        hasCamera: webcamState.hasCamera\n      });\n    }\n\n    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading\n    , _extends({}, webcamState, {\n      onChangeVideoSource: this.changeVideoSource,\n      onSnapshot: this.takeSnapshot,\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onDiscardRecordedVideo: this.discardRecordedVideo,\n      onSubmit: this.submit,\n      onFocus: this.focus,\n      onStop: this.stop,\n      i18n: this.i18n,\n      modes: this.opts.modes,\n      showRecordingLength: this.opts.showRecordingLength,\n      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,\n      supportsRecording: supportsMediaRecorder(),\n      recording: webcamState.isRecording,\n      mirror: _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror],\n      src: this.stream\n    }));\n  }\n\n  install() {\n    const {\n      mobileNativeCamera,\n      modes,\n      facingMode,\n      videoConstraints\n    } = this.opts;\n    const {\n      target\n    } = this.opts;\n\n    if (mobileNativeCamera && target) {\n      var _this$getTargetPlugin;\n\n      (_this$getTargetPlugin = this.getTargetPlugin(target)) == null ? void 0 : _this$getTargetPlugin.setOptions({\n        showNativeVideoCameraButton: isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'video-audio'),\n        showNativePhotoCameraButton: isModeAvailable(modes, 'picture'),\n        nativeCameraFacingMode: (videoConstraints == null ? void 0 : videoConstraints.facingMode) || facingMode\n      });\n      return;\n    }\n\n    this.setPluginState({\n      cameraReady: false,\n      recordingLengthSeconds: 0\n    });\n\n    if (target) {\n      this.mount(target, this);\n    }\n\n    if (this.mediaDevices) {\n      this.updateVideoSources();\n\n      this.mediaDevices.ondevicechange = () => {\n        this.updateVideoSources();\n\n        if (this.stream) {\n          let restartStream = true;\n          const {\n            videoSources,\n            currentDeviceId\n          } = this.getPluginState();\n          videoSources.forEach(videoSource => {\n            if (currentDeviceId === videoSource.deviceId) {\n              restartStream = false;\n            }\n          });\n\n          if (restartStream) {\n            this.stop();\n            this.start();\n          }\n        }\n      };\n    }\n  }\n\n  uninstall() {\n    this.stop();\n    this.unmount();\n  }\n\n  onUnmount() {\n    this.stop();\n  }\n\n}\nWebcam.VERSION = packageJson.version;"],"mappings":"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"},"metadata":{},"sourceType":"module"}