{"ast":null,"code":"function _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { Provider, RequestClient, Socket } from '@uppy/companion-client';\nimport emitSocketProgress from '@uppy/utils/lib/emitSocketProgress';\nimport getSocketHost from '@uppy/utils/lib/getSocketHost';\nimport settle from '@uppy/utils/lib/settle';\nimport EventTracker from '@uppy/utils/lib/EventTracker';\nimport ProgressTimeout from '@uppy/utils/lib/ProgressTimeout';\nimport { RateLimitedQueue, internalRateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport isNetworkError from '@uppy/utils/lib/isNetworkError';\nconst packageJson = {\n  \"version\": \"3.0.4\"\n};\nimport locale from './locale.js';\nfunction buildResponseError(xhr, err) {\n  let error = err; // No error message\n\n  if (!error) error = new Error('Upload error'); // Got an error message string\n\n  if (typeof error === 'string') error = new Error(error); // Got something else\n\n  if (!(error instanceof Error)) {\n    error = Object.assign(new Error('Upload error'), {\n      data: error\n    });\n  }\n  if (isNetworkError(xhr)) {\n    error = new NetworkError(error, xhr);\n    return error;\n  }\n  error.request = xhr;\n  return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n *\n * @param {object} file File object with `data`, `size` and `meta` properties\n * @returns {object} blob updated with the new `type` set from `file.meta.type`\n */\n\nfunction setTypeInBlob(file) {\n  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\nvar _queueRequestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueRequestSocketToken\");\nvar _requestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestSocketToken\");\nexport default class XHRUpload extends BasePlugin {\n  // eslint-disable-next-line global-require\n  constructor(uppy, _opts) {\n    super(uppy, _opts);\n    Object.defineProperty(this, _queueRequestSocketToken, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requestSocketToken, {\n      writable: true,\n      value: async file => {\n        const opts = this.getOptions(file);\n        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n        const client = new Client(this.uppy, file.remote.providerOptions);\n        const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields // Send along all fields by default.\n        : Object.keys(file.meta);\n        const res = await client.post(file.remote.url, {\n          ...file.remote.body,\n          protocol: 'multipart',\n          endpoint: opts.endpoint,\n          size: file.data.size,\n          fieldname: opts.fieldName,\n          metadata: Object.fromEntries(allowedMetaFields.map(name => [name, file.meta[name]])),\n          httpMethod: opts.method,\n          useFormData: opts.formData,\n          headers: opts.headers\n        });\n        return res.token;\n      }\n    });\n    this.type = 'uploader';\n    this.id = this.opts.id || 'XHRUpload';\n    this.title = 'XHRUpload';\n    this.defaultLocale = locale; // Default options\n\n    const defaultOptions = {\n      formData: true,\n      fieldName: _opts.bundle ? 'files[]' : 'file',\n      method: 'post',\n      allowedMetaFields: null,\n      responseUrlFieldName: 'url',\n      bundle: false,\n      headers: {},\n      timeout: 30 * 1000,\n      limit: 5,\n      withCredentials: false,\n      responseType: '',\n      /**\n       * @param {string} responseText the response body string\n       */\n      getResponseData(responseText) {\n        let parsedResponse = {};\n        try {\n          parsedResponse = JSON.parse(responseText);\n        } catch (err) {\n          uppy.log(err);\n        }\n        return parsedResponse;\n      },\n      /**\n       *\n       * @param {string} _ the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      getResponseError(_, response) {\n        let error = new Error('Upload error');\n        if (isNetworkError(response)) {\n          error = new NetworkError(error, response);\n        }\n        return error;\n      },\n      /**\n       * Check if the response from the upload endpoint indicates that the upload was successful.\n       *\n       * @param {number} status the response status code\n       */\n      validateStatus(status) {\n        return status >= 200 && status < 300;\n      }\n    };\n    this.opts = {\n      ...defaultOptions,\n      ..._opts\n    };\n    this.i18nInit();\n    this.handleUpload = this.handleUpload.bind(this); // Simultaneous upload limiting is shared across all uploads with this plugin.\n\n    if (internalRateLimitedQueue in this.opts) {\n      this.requests = this.opts[internalRateLimitedQueue];\n    } else {\n      this.requests = new RateLimitedQueue(this.opts.limit);\n    }\n    if (this.opts.bundle && !this.opts.formData) {\n      throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n    }\n    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === undefined && 'metaFields' in this.opts) {\n      throw new Error('The `metaFields` option has been renamed to `allowedMetaFields`.');\n    }\n    this.uploaderEvents = Object.create(null);\n    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase(this, _requestSocketToken)[_requestSocketToken], {\n      priority: -1\n    });\n  }\n  getOptions(file) {\n    const overrides = this.uppy.getState().xhrUpload;\n    const {\n      headers\n    } = this.opts;\n    const opts = {\n      ...this.opts,\n      ...(overrides || {}),\n      ...(file.xhrUpload || {}),\n      headers: {}\n    }; // Support for `headers` as a function, only in the XHRUpload settings.\n    // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n    //\n    // ```js\n    // headers: (file) => ({ expires: file.meta.expires })\n    // ```\n\n    if (typeof headers === 'function') {\n      opts.headers = headers(file);\n    } else {\n      Object.assign(opts.headers, this.opts.headers);\n    }\n    if (overrides) {\n      Object.assign(opts.headers, overrides.headers);\n    }\n    if (file.xhrUpload) {\n      Object.assign(opts.headers, file.xhrUpload.headers);\n    }\n    return opts;\n  } // eslint-disable-next-line class-methods-use-this\n\n  addMetadata(formData, meta, opts) {\n    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta); // Send along all fields by default.\n\n    allowedMetaFields.forEach(item => {\n      formData.append(item, meta[item]);\n    });\n  }\n  createFormDataUpload(file, opts) {\n    const formPost = new FormData();\n    this.addMetadata(formPost, file.meta, opts);\n    const dataWithUpdatedType = setTypeInBlob(file);\n    if (file.name) {\n      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n    } else {\n      formPost.append(opts.fieldName, dataWithUpdatedType);\n    }\n    return formPost;\n  }\n  createBundledUpload(files, opts) {\n    const formPost = new FormData();\n    const {\n      meta\n    } = this.uppy.getState();\n    this.addMetadata(formPost, meta, opts);\n    files.forEach(file => {\n      const options = this.getOptions(file);\n      const dataWithUpdatedType = setTypeInBlob(file);\n      if (file.name) {\n        formPost.append(options.fieldName, dataWithUpdatedType, file.name);\n      } else {\n        formPost.append(options.fieldName, dataWithUpdatedType);\n      }\n    });\n    return formPost;\n  }\n  upload(file, current, total) {\n    const opts = this.getOptions(file);\n    this.uppy.log(`uploading ${current} of ${total}`);\n    return new Promise((resolve, reject) => {\n      this.uppy.emit('upload-started', file);\n      const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;\n      const xhr = new XMLHttpRequest();\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest;\n      const timer = new ProgressTimeout(opts.timeout, () => {\n        xhr.abort();\n        queuedRequest.done();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(opts.timeout / 1000)\n        }));\n        this.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n      const id = nanoid();\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log(`[XHRUpload] ${id} started`);\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        this.uppy.log(`[XHRUpload] ${id} progress: ${ev.loaded} / ${ev.total}`); // Begin checking for timeouts when progress starts, instead of loading,\n        // to avoid timing out requests on browser concurrency queue\n\n        timer.progress();\n        if (ev.lengthComputable) {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n      xhr.addEventListener('load', () => {\n        this.uppy.log(`[XHRUpload] ${id} finished`);\n        timer.done();\n        queuedRequest.done();\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n        if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {\n          const body = opts.getResponseData(xhr.responseText, xhr);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: xhr.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          if (uploadURL) {\n            this.uppy.log(`Download ${file.name} from ${uploadURL}`);\n          }\n          return resolve(file);\n        }\n        const body = opts.getResponseData(xhr.responseText, xhr);\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        const response = {\n          status: xhr.status,\n          body\n        };\n        this.uppy.emit('upload-error', file, error, response);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        this.uppy.log(`[XHRUpload] ${id} errored`);\n        timer.done();\n        queuedRequest.done();\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        this.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = opts.withCredentials;\n      if (opts.responseType !== '') {\n        xhr.responseType = opts.responseType;\n      }\n      queuedRequest = this.requests.run(() => {\n        this.uppy.emit('upload-started', file); // When using an authentication system like JWT, the bearer token goes as a header. This\n        // header needs to be fresh each time the token is refreshed so computing and setting the\n        // headers just before the upload starts enables this kind of authentication to work properly.\n        // Otherwise, half-way through the list of uploads the token could be stale and the upload would fail.\n\n        const currentOpts = this.getOptions(file);\n        Object.keys(currentOpts.headers).forEach(header => {\n          xhr.setRequestHeader(header, currentOpts.headers[header]);\n        });\n        xhr.send(data);\n        return () => {\n          timer.done();\n          xhr.abort();\n        };\n      });\n      this.onFileRemove(file.id, () => {\n        queuedRequest.abort();\n        reject(new Error('File removed'));\n      });\n      this.onCancelAll(file.id, _ref => {\n        let {\n          reason\n        } = _ref;\n        if (reason === 'user') {\n          queuedRequest.abort();\n        }\n        reject(new Error('Upload cancelled'));\n      });\n    });\n  }\n  async uploadRemote(file) {\n    // TODO: we could rewrite this to use server-sent events instead of creating WebSockets.\n    try {\n      this.uppy.emit('upload-started', file);\n      if (file.serverToken) {\n        return this.connectToServerSocket(file);\n      }\n      const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file);\n      if (!this.uppy.getState().files[file.id]) return undefined;\n      this.uppy.setFileState(file.id, {\n        serverToken\n      });\n      return this.connectToServerSocket(this.uppy.getFile(file.id));\n    } catch (err) {\n      this.uppy.emit('upload-error', file, err);\n      throw err;\n    }\n  }\n  connectToServerSocket(file) {\n    return new Promise((resolve, reject) => {\n      const opts = this.getOptions(file);\n      const token = file.serverToken;\n      const host = getSocketHost(file.remote.companionUrl);\n      let socket;\n      const createSocket = () => {\n        if (socket != null) return;\n        socket = new Socket({\n          target: `${host}/api/${token}`\n        });\n        socket.on('progress', progressData => emitSocketProgress(this, progressData, file));\n        socket.on('success', data => {\n          const body = opts.getResponseData(data.response.responseText, data.response);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: data.response.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          socket.close();\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          return resolve();\n        });\n        socket.on('error', errData => {\n          const resp = errData.response;\n          const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {\n            cause: errData.error\n          });\n          this.uppy.emit('upload-error', file, error);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          reject(error);\n        });\n      };\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest = this.requests.run(() => {\n        if (file.isPaused) {\n          var _socket;\n          (_socket = socket) == null ? void 0 : _socket.send('pause', {});\n        } else {\n          createSocket();\n        }\n        return () => socket.close();\n      });\n      this.onFileRemove(file.id, () => {\n        var _socket2;\n        (_socket2 = socket) == null ? void 0 : _socket2.send('cancel', {});\n        queuedRequest.abort();\n        resolve(`upload ${file.id} was removed`);\n      });\n      this.onCancelAll(file.id, function (_temp) {\n        let {\n          reason\n        } = _temp === void 0 ? {} : _temp;\n        if (reason === 'user') {\n          var _socket3;\n          (_socket3 = socket) == null ? void 0 : _socket3.send('cancel', {});\n          queuedRequest.abort();\n        }\n        resolve(`upload ${file.id} was canceled`);\n      });\n      const onRetryRequest = () => {\n        if (socket == null) {\n          queuedRequest.abort();\n        } else {\n          socket.send('pause', {});\n          queuedRequest.done();\n        }\n        queuedRequest = this.requests.run(() => {\n          if (!file.isPaused) {\n            if (socket == null) {\n              createSocket();\n            } else {\n              socket.send('resume', {});\n            }\n          }\n          return () => socket.close();\n        });\n      };\n      this.onRetry(file.id, onRetryRequest);\n      this.onRetryAll(file.id, onRetryRequest);\n    }).catch(err => {\n      this.uppy.emit('upload-error', file, err);\n      return Promise.reject(err);\n    });\n  }\n  uploadBundle(files) {\n    return new Promise((resolve, reject) => {\n      const {\n        endpoint\n      } = this.opts;\n      const {\n        method\n      } = this.opts;\n      const optsFromState = this.uppy.getState().xhrUpload;\n      const formData = this.createBundledUpload(files, {\n        ...this.opts,\n        ...(optsFromState || {})\n      });\n      const xhr = new XMLHttpRequest();\n      const emitError = error => {\n        files.forEach(file => {\n          this.uppy.emit('upload-error', file, error);\n        });\n      };\n      const timer = new ProgressTimeout(this.opts.timeout, () => {\n        xhr.abort();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(this.opts.timeout / 1000)\n        }));\n        emitError(error);\n        reject(error);\n      });\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log('[XHRUpload] started uploading bundle');\n        timer.progress();\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        timer.progress();\n        if (!ev.lengthComputable) return;\n        files.forEach(file => {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded / ev.total * file.size,\n            bytesTotal: file.size\n          });\n        });\n      });\n      xhr.addEventListener('load', ev => {\n        timer.done();\n        if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          const body = this.opts.getResponseData(xhr.responseText, xhr);\n          const uploadResp = {\n            status: ev.target.status,\n            body\n          };\n          files.forEach(file => {\n            this.uppy.emit('upload-success', file, uploadResp);\n          });\n          return resolve();\n        }\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        error.request = xhr;\n        emitError(error);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        timer.done();\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        emitError(error);\n        return reject(error);\n      });\n      this.uppy.on('cancel-all', function (_temp2) {\n        let {\n          reason\n        } = _temp2 === void 0 ? {} : _temp2;\n        if (reason !== 'user') return;\n        timer.done();\n        xhr.abort();\n      });\n      xhr.open(method.toUpperCase(), endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = this.opts.withCredentials;\n      if (this.opts.responseType !== '') {\n        xhr.responseType = this.opts.responseType;\n      }\n      Object.keys(this.opts.headers).forEach(header => {\n        xhr.setRequestHeader(header, this.opts.headers[header]);\n      });\n      xhr.send(formData);\n      files.forEach(file => {\n        this.uppy.emit('upload-started', file);\n      });\n    });\n  }\n  uploadFiles(files) {\n    const promises = files.map((file, i) => {\n      const current = parseInt(i, 10) + 1;\n      const total = files.length;\n      if (file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n      if (file.isRemote) {\n        return this.uploadRemote(file, current, total);\n      }\n      return this.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', file => {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', targetFileID => {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  onRetryAll(fileID, cb) {\n    this.uploaderEvents[fileID].on('retry-all', () => {\n      if (!this.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  onCancelAll(fileID, eventHandler) {\n    var _this = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this.uppy.getFile(fileID)) return;\n      eventHandler(...arguments);\n    });\n  }\n  handleUpload(fileIDs) {\n    if (fileIDs.length === 0) {\n      this.uppy.log('[XHRUpload] No files to upload!');\n      return Promise.resolve();\n    } // No limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin\n    // (basically just AwsS3) using the internal symbol\n\n    if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {\n      this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n    }\n    this.uppy.log('[XHRUpload] Uploading...');\n    const files = fileIDs.map(fileID => this.uppy.getFile(fileID));\n    if (this.opts.bundle) {\n      // if bundle: true, we don’t support remote uploads\n      const isSomeFileRemote = files.some(file => file.isRemote);\n      if (isSomeFileRemote) {\n        throw new Error('Can’t upload remote files when the `bundle: true` option is set');\n      }\n      if (typeof this.opts.headers === 'function') {\n        throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n      }\n      return this.uploadBundle(files);\n    }\n    return this.uploadFiles(files).then(() => null);\n  }\n  install() {\n    if (this.opts.bundle) {\n      const {\n        capabilities\n      } = this.uppy.getState();\n      this.uppy.setState({\n        capabilities: {\n          ...capabilities,\n          individualCancellation: false\n        }\n      });\n    }\n    this.uppy.addUploader(this.handleUpload);\n  }\n  uninstall() {\n    if (this.opts.bundle) {\n      const {\n        capabilities\n      } = this.uppy.getState();\n      this.uppy.setState({\n        capabilities: {\n          ...capabilities,\n          individualCancellation: true\n        }\n      });\n    }\n    this.uppy.removeUploader(this.handleUpload);\n  }\n}\nXHRUpload.VERSION = packageJson.version;","map":{"version":3,"names":["_classPrivateFieldLooseBase","receiver","privateKey","Object","prototype","hasOwnProperty","call","TypeError","id","_classPrivateFieldLooseKey","name","BasePlugin","nanoid","Provider","RequestClient","Socket","emitSocketProgress","getSocketHost","settle","EventTracker","ProgressTimeout","RateLimitedQueue","internalRateLimitedQueue","NetworkError","isNetworkError","packageJson","locale","buildResponseError","xhr","err","error","Error","assign","data","request","setTypeInBlob","file","dataWithUpdatedType","slice","size","meta","type","_queueRequestSocketToken","_requestSocketToken","XHRUpload","constructor","uppy","_opts","defineProperty","writable","value","opts","getOptions","Client","remote","providerOptions","provider","client","allowedMetaFields","Array","isArray","keys","res","post","url","body","protocol","endpoint","fieldname","fieldName","metadata","fromEntries","map","httpMethod","method","useFormData","formData","headers","token","title","defaultLocale","defaultOptions","bundle","responseUrlFieldName","timeout","limit","withCredentials","responseType","getResponseData","responseText","parsedResponse","JSON","parse","log","getResponseError","_","response","validateStatus","status","i18nInit","handleUpload","bind","requests","undefined","uploaderEvents","create","wrapPromiseFunction","priority","overrides","getState","xhrUpload","addMetadata","forEach","item","append","createFormDataUpload","formPost","FormData","createBundledUpload","files","options","upload","current","total","Promise","resolve","reject","emit","XMLHttpRequest","queuedRequest","timer","abort","done","i18n","seconds","Math","ceil","addEventListener","ev","loaded","progress","lengthComputable","uploader","bytesUploaded","bytesTotal","remove","uploadURL","uploadResp","open","toUpperCase","run","currentOpts","header","setRequestHeader","send","onFileRemove","onCancelAll","_ref","reason","uploadRemote","serverToken","connectToServerSocket","setFileState","getFile","host","companionUrl","socket","createSocket","target","on","progressData","close","errData","resp","message","cause","isPaused","_socket","_socket2","_temp","_socket3","onRetryRequest","onRetry","onRetryAll","catch","uploadBundle","optsFromState","emitError","_temp2","uploadFiles","promises","i","parseInt","length","isRemote","fileID","cb","targetFileID","eventHandler","_this","arguments","fileIDs","isSomeFileRemote","some","then","install","capabilities","setState","individualCancellation","addUploader","uninstall","removeUploader","VERSION","version"],"sources":["/lab/node_modules/@uppy/xhr-upload/lib/index.js"],"sourcesContent":["function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\n\nvar id = 0;\n\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\n\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { Provider, RequestClient, Socket } from '@uppy/companion-client';\nimport emitSocketProgress from '@uppy/utils/lib/emitSocketProgress';\nimport getSocketHost from '@uppy/utils/lib/getSocketHost';\nimport settle from '@uppy/utils/lib/settle';\nimport EventTracker from '@uppy/utils/lib/EventTracker';\nimport ProgressTimeout from '@uppy/utils/lib/ProgressTimeout';\nimport { RateLimitedQueue, internalRateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport isNetworkError from '@uppy/utils/lib/isNetworkError';\nconst packageJson = {\n  \"version\": \"3.0.4\"\n};\nimport locale from './locale.js';\n\nfunction buildResponseError(xhr, err) {\n  let error = err; // No error message\n\n  if (!error) error = new Error('Upload error'); // Got an error message string\n\n  if (typeof error === 'string') error = new Error(error); // Got something else\n\n  if (!(error instanceof Error)) {\n    error = Object.assign(new Error('Upload error'), {\n      data: error\n    });\n  }\n\n  if (isNetworkError(xhr)) {\n    error = new NetworkError(error, xhr);\n    return error;\n  }\n\n  error.request = xhr;\n  return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n *\n * @param {object} file File object with `data`, `size` and `meta` properties\n * @returns {object} blob updated with the new `type` set from `file.meta.type`\n */\n\n\nfunction setTypeInBlob(file) {\n  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\n\nvar _queueRequestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueRequestSocketToken\");\n\nvar _requestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestSocketToken\");\n\nexport default class XHRUpload extends BasePlugin {\n  // eslint-disable-next-line global-require\n  constructor(uppy, _opts) {\n    super(uppy, _opts);\n    Object.defineProperty(this, _queueRequestSocketToken, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requestSocketToken, {\n      writable: true,\n      value: async file => {\n        const opts = this.getOptions(file);\n        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n        const client = new Client(this.uppy, file.remote.providerOptions);\n        const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields // Send along all fields by default.\n        : Object.keys(file.meta);\n        const res = await client.post(file.remote.url, { ...file.remote.body,\n          protocol: 'multipart',\n          endpoint: opts.endpoint,\n          size: file.data.size,\n          fieldname: opts.fieldName,\n          metadata: Object.fromEntries(allowedMetaFields.map(name => [name, file.meta[name]])),\n          httpMethod: opts.method,\n          useFormData: opts.formData,\n          headers: opts.headers\n        });\n        return res.token;\n      }\n    });\n    this.type = 'uploader';\n    this.id = this.opts.id || 'XHRUpload';\n    this.title = 'XHRUpload';\n    this.defaultLocale = locale; // Default options\n\n    const defaultOptions = {\n      formData: true,\n      fieldName: _opts.bundle ? 'files[]' : 'file',\n      method: 'post',\n      allowedMetaFields: null,\n      responseUrlFieldName: 'url',\n      bundle: false,\n      headers: {},\n      timeout: 30 * 1000,\n      limit: 5,\n      withCredentials: false,\n      responseType: '',\n\n      /**\n       * @param {string} responseText the response body string\n       */\n      getResponseData(responseText) {\n        let parsedResponse = {};\n\n        try {\n          parsedResponse = JSON.parse(responseText);\n        } catch (err) {\n          uppy.log(err);\n        }\n\n        return parsedResponse;\n      },\n\n      /**\n       *\n       * @param {string} _ the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      getResponseError(_, response) {\n        let error = new Error('Upload error');\n\n        if (isNetworkError(response)) {\n          error = new NetworkError(error, response);\n        }\n\n        return error;\n      },\n\n      /**\n       * Check if the response from the upload endpoint indicates that the upload was successful.\n       *\n       * @param {number} status the response status code\n       */\n      validateStatus(status) {\n        return status >= 200 && status < 300;\n      }\n\n    };\n    this.opts = { ...defaultOptions,\n      ..._opts\n    };\n    this.i18nInit();\n    this.handleUpload = this.handleUpload.bind(this); // Simultaneous upload limiting is shared across all uploads with this plugin.\n\n    if (internalRateLimitedQueue in this.opts) {\n      this.requests = this.opts[internalRateLimitedQueue];\n    } else {\n      this.requests = new RateLimitedQueue(this.opts.limit);\n    }\n\n    if (this.opts.bundle && !this.opts.formData) {\n      throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n    }\n\n    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === undefined && 'metaFields' in this.opts) {\n      throw new Error('The `metaFields` option has been renamed to `allowedMetaFields`.');\n    }\n\n    this.uploaderEvents = Object.create(null);\n    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase(this, _requestSocketToken)[_requestSocketToken], {\n      priority: -1\n    });\n  }\n\n  getOptions(file) {\n    const overrides = this.uppy.getState().xhrUpload;\n    const {\n      headers\n    } = this.opts;\n    const opts = { ...this.opts,\n      ...(overrides || {}),\n      ...(file.xhrUpload || {}),\n      headers: {}\n    }; // Support for `headers` as a function, only in the XHRUpload settings.\n    // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n    //\n    // ```js\n    // headers: (file) => ({ expires: file.meta.expires })\n    // ```\n\n    if (typeof headers === 'function') {\n      opts.headers = headers(file);\n    } else {\n      Object.assign(opts.headers, this.opts.headers);\n    }\n\n    if (overrides) {\n      Object.assign(opts.headers, overrides.headers);\n    }\n\n    if (file.xhrUpload) {\n      Object.assign(opts.headers, file.xhrUpload.headers);\n    }\n\n    return opts;\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  addMetadata(formData, meta, opts) {\n    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta); // Send along all fields by default.\n\n    allowedMetaFields.forEach(item => {\n      formData.append(item, meta[item]);\n    });\n  }\n\n  createFormDataUpload(file, opts) {\n    const formPost = new FormData();\n    this.addMetadata(formPost, file.meta, opts);\n    const dataWithUpdatedType = setTypeInBlob(file);\n\n    if (file.name) {\n      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n    } else {\n      formPost.append(opts.fieldName, dataWithUpdatedType);\n    }\n\n    return formPost;\n  }\n\n  createBundledUpload(files, opts) {\n    const formPost = new FormData();\n    const {\n      meta\n    } = this.uppy.getState();\n    this.addMetadata(formPost, meta, opts);\n    files.forEach(file => {\n      const options = this.getOptions(file);\n      const dataWithUpdatedType = setTypeInBlob(file);\n\n      if (file.name) {\n        formPost.append(options.fieldName, dataWithUpdatedType, file.name);\n      } else {\n        formPost.append(options.fieldName, dataWithUpdatedType);\n      }\n    });\n    return formPost;\n  }\n\n  upload(file, current, total) {\n    const opts = this.getOptions(file);\n    this.uppy.log(`uploading ${current} of ${total}`);\n    return new Promise((resolve, reject) => {\n      this.uppy.emit('upload-started', file);\n      const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;\n      const xhr = new XMLHttpRequest();\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest;\n      const timer = new ProgressTimeout(opts.timeout, () => {\n        xhr.abort();\n        queuedRequest.done();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(opts.timeout / 1000)\n        }));\n        this.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n      const id = nanoid();\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log(`[XHRUpload] ${id} started`);\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        this.uppy.log(`[XHRUpload] ${id} progress: ${ev.loaded} / ${ev.total}`); // Begin checking for timeouts when progress starts, instead of loading,\n        // to avoid timing out requests on browser concurrency queue\n\n        timer.progress();\n\n        if (ev.lengthComputable) {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n      xhr.addEventListener('load', () => {\n        this.uppy.log(`[XHRUpload] ${id} finished`);\n        timer.done();\n        queuedRequest.done();\n\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n\n        if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {\n          const body = opts.getResponseData(xhr.responseText, xhr);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: xhr.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n\n          if (uploadURL) {\n            this.uppy.log(`Download ${file.name} from ${uploadURL}`);\n          }\n\n          return resolve(file);\n        }\n\n        const body = opts.getResponseData(xhr.responseText, xhr);\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        const response = {\n          status: xhr.status,\n          body\n        };\n        this.uppy.emit('upload-error', file, error, response);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        this.uppy.log(`[XHRUpload] ${id} errored`);\n        timer.done();\n        queuedRequest.done();\n\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        this.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = opts.withCredentials;\n\n      if (opts.responseType !== '') {\n        xhr.responseType = opts.responseType;\n      }\n\n      queuedRequest = this.requests.run(() => {\n        this.uppy.emit('upload-started', file); // When using an authentication system like JWT, the bearer token goes as a header. This\n        // header needs to be fresh each time the token is refreshed so computing and setting the\n        // headers just before the upload starts enables this kind of authentication to work properly.\n        // Otherwise, half-way through the list of uploads the token could be stale and the upload would fail.\n\n        const currentOpts = this.getOptions(file);\n        Object.keys(currentOpts.headers).forEach(header => {\n          xhr.setRequestHeader(header, currentOpts.headers[header]);\n        });\n        xhr.send(data);\n        return () => {\n          timer.done();\n          xhr.abort();\n        };\n      });\n      this.onFileRemove(file.id, () => {\n        queuedRequest.abort();\n        reject(new Error('File removed'));\n      });\n      this.onCancelAll(file.id, _ref => {\n        let {\n          reason\n        } = _ref;\n\n        if (reason === 'user') {\n          queuedRequest.abort();\n        }\n\n        reject(new Error('Upload cancelled'));\n      });\n    });\n  }\n\n  async uploadRemote(file) {\n    // TODO: we could rewrite this to use server-sent events instead of creating WebSockets.\n    try {\n      this.uppy.emit('upload-started', file);\n\n      if (file.serverToken) {\n        return this.connectToServerSocket(file);\n      }\n\n      const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file);\n      if (!this.uppy.getState().files[file.id]) return undefined;\n      this.uppy.setFileState(file.id, {\n        serverToken\n      });\n      return this.connectToServerSocket(this.uppy.getFile(file.id));\n    } catch (err) {\n      this.uppy.emit('upload-error', file, err);\n      throw err;\n    }\n  }\n\n  connectToServerSocket(file) {\n    return new Promise((resolve, reject) => {\n      const opts = this.getOptions(file);\n      const token = file.serverToken;\n      const host = getSocketHost(file.remote.companionUrl);\n      let socket;\n\n      const createSocket = () => {\n        if (socket != null) return;\n        socket = new Socket({\n          target: `${host}/api/${token}`\n        });\n        socket.on('progress', progressData => emitSocketProgress(this, progressData, file));\n        socket.on('success', data => {\n          const body = opts.getResponseData(data.response.responseText, data.response);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: data.response.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          socket.close();\n\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n\n          return resolve();\n        });\n        socket.on('error', errData => {\n          const resp = errData.response;\n          const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {\n            cause: errData.error\n          });\n          this.uppy.emit('upload-error', file, error);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n\n          reject(error);\n        });\n      };\n\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest = this.requests.run(() => {\n        if (file.isPaused) {\n          var _socket;\n\n          (_socket = socket) == null ? void 0 : _socket.send('pause', {});\n        } else {\n          createSocket();\n        }\n\n        return () => socket.close();\n      });\n      this.onFileRemove(file.id, () => {\n        var _socket2;\n\n        (_socket2 = socket) == null ? void 0 : _socket2.send('cancel', {});\n        queuedRequest.abort();\n        resolve(`upload ${file.id} was removed`);\n      });\n      this.onCancelAll(file.id, function (_temp) {\n        let {\n          reason\n        } = _temp === void 0 ? {} : _temp;\n\n        if (reason === 'user') {\n          var _socket3;\n\n          (_socket3 = socket) == null ? void 0 : _socket3.send('cancel', {});\n          queuedRequest.abort();\n        }\n\n        resolve(`upload ${file.id} was canceled`);\n      });\n\n      const onRetryRequest = () => {\n        if (socket == null) {\n          queuedRequest.abort();\n        } else {\n          socket.send('pause', {});\n          queuedRequest.done();\n        }\n\n        queuedRequest = this.requests.run(() => {\n          if (!file.isPaused) {\n            if (socket == null) {\n              createSocket();\n            } else {\n              socket.send('resume', {});\n            }\n          }\n\n          return () => socket.close();\n        });\n      };\n\n      this.onRetry(file.id, onRetryRequest);\n      this.onRetryAll(file.id, onRetryRequest);\n    }).catch(err => {\n      this.uppy.emit('upload-error', file, err);\n      return Promise.reject(err);\n    });\n  }\n\n  uploadBundle(files) {\n    return new Promise((resolve, reject) => {\n      const {\n        endpoint\n      } = this.opts;\n      const {\n        method\n      } = this.opts;\n      const optsFromState = this.uppy.getState().xhrUpload;\n      const formData = this.createBundledUpload(files, { ...this.opts,\n        ...(optsFromState || {})\n      });\n      const xhr = new XMLHttpRequest();\n\n      const emitError = error => {\n        files.forEach(file => {\n          this.uppy.emit('upload-error', file, error);\n        });\n      };\n\n      const timer = new ProgressTimeout(this.opts.timeout, () => {\n        xhr.abort();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(this.opts.timeout / 1000)\n        }));\n        emitError(error);\n        reject(error);\n      });\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log('[XHRUpload] started uploading bundle');\n        timer.progress();\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        timer.progress();\n        if (!ev.lengthComputable) return;\n        files.forEach(file => {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded / ev.total * file.size,\n            bytesTotal: file.size\n          });\n        });\n      });\n      xhr.addEventListener('load', ev => {\n        timer.done();\n\n        if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          const body = this.opts.getResponseData(xhr.responseText, xhr);\n          const uploadResp = {\n            status: ev.target.status,\n            body\n          };\n          files.forEach(file => {\n            this.uppy.emit('upload-success', file, uploadResp);\n          });\n          return resolve();\n        }\n\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        error.request = xhr;\n        emitError(error);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        timer.done();\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        emitError(error);\n        return reject(error);\n      });\n      this.uppy.on('cancel-all', function (_temp2) {\n        let {\n          reason\n        } = _temp2 === void 0 ? {} : _temp2;\n        if (reason !== 'user') return;\n        timer.done();\n        xhr.abort();\n      });\n      xhr.open(method.toUpperCase(), endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = this.opts.withCredentials;\n\n      if (this.opts.responseType !== '') {\n        xhr.responseType = this.opts.responseType;\n      }\n\n      Object.keys(this.opts.headers).forEach(header => {\n        xhr.setRequestHeader(header, this.opts.headers[header]);\n      });\n      xhr.send(formData);\n      files.forEach(file => {\n        this.uppy.emit('upload-started', file);\n      });\n    });\n  }\n\n  uploadFiles(files) {\n    const promises = files.map((file, i) => {\n      const current = parseInt(i, 10) + 1;\n      const total = files.length;\n\n      if (file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n\n      if (file.isRemote) {\n        return this.uploadRemote(file, current, total);\n      }\n\n      return this.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n\n  onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', file => {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n\n  onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', targetFileID => {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n\n  onRetryAll(fileID, cb) {\n    this.uploaderEvents[fileID].on('retry-all', () => {\n      if (!this.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n\n  onCancelAll(fileID, eventHandler) {\n    var _this = this;\n\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this.uppy.getFile(fileID)) return;\n      eventHandler(...arguments);\n    });\n  }\n\n  handleUpload(fileIDs) {\n    if (fileIDs.length === 0) {\n      this.uppy.log('[XHRUpload] No files to upload!');\n      return Promise.resolve();\n    } // No limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin\n    // (basically just AwsS3) using the internal symbol\n\n\n    if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {\n      this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n    }\n\n    this.uppy.log('[XHRUpload] Uploading...');\n    const files = fileIDs.map(fileID => this.uppy.getFile(fileID));\n\n    if (this.opts.bundle) {\n      // if bundle: true, we don’t support remote uploads\n      const isSomeFileRemote = files.some(file => file.isRemote);\n\n      if (isSomeFileRemote) {\n        throw new Error('Can’t upload remote files when the `bundle: true` option is set');\n      }\n\n      if (typeof this.opts.headers === 'function') {\n        throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n      }\n\n      return this.uploadBundle(files);\n    }\n\n    return this.uploadFiles(files).then(() => null);\n  }\n\n  install() {\n    if (this.opts.bundle) {\n      const {\n        capabilities\n      } = this.uppy.getState();\n      this.uppy.setState({\n        capabilities: { ...capabilities,\n          individualCancellation: false\n        }\n      });\n    }\n\n    this.uppy.addUploader(this.handleUpload);\n  }\n\n  uninstall() {\n    if (this.opts.bundle) {\n      const {\n        capabilities\n      } = this.uppy.getState();\n      this.uppy.setState({\n        capabilities: { ...capabilities,\n          individualCancellation: true\n        }\n      });\n    }\n\n    this.uppy.removeUploader(this.handleUpload);\n  }\n\n}\nXHRUpload.VERSION = packageJson.version;"],"mappings":"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"},"metadata":{},"sourceType":"module"}