{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nconst DATA_URL_PATTERN = /^data:([^/]+\\/[^,;]+(?:[^,]*?))(;base64)?,([\\s\\S]*)$/;\nexport default function dataURItoBlob(dataURI, opts, toFile) {\n  var _ref, _opts$mimeType;\n\n  // get the base64 data\n  const dataURIData = DATA_URL_PATTERN.exec(dataURI); // user may provide mime type, if not get it from data URI\n\n  const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : 'plain/text';\n  let data;\n  if (dataURIData[2] != null) {\n    const binary = atob(decodeURIComponent(dataURIData[3]));\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    data = [bytes];\n  } else {\n    data = [decodeURIComponent(dataURIData[3])];\n  } // Convert to a File?\n\n  if (toFile) {\n    return new File(data, opts.name || '', {\n      type: mimeType\n    });\n  }\n  return new Blob(data, {\n    type: mimeType\n  });\n}","map":{"version":3,"names":["DATA_URL_PATTERN","dataURItoBlob","dataURI","opts","toFile","_ref","_opts$mimeType","dataURIData","exec","mimeType","data","binary","atob","decodeURIComponent","bytes","Uint8Array","length","i","charCodeAt","File","name","type","Blob"],"sources":["/lab/node_modules/@uppy/utils/lib/dataURItoBlob.js"],"sourcesContent":["const DATA_URL_PATTERN = /^data:([^/]+\\/[^,;]+(?:[^,]*?))(;base64)?,([\\s\\S]*)$/;\nexport default function dataURItoBlob(dataURI, opts, toFile) {\n  var _ref, _opts$mimeType;\n\n  // get the base64 data\n  const dataURIData = DATA_URL_PATTERN.exec(dataURI); // user may provide mime type, if not get it from data URI\n\n  const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : 'plain/text';\n  let data;\n\n  if (dataURIData[2] != null) {\n    const binary = atob(decodeURIComponent(dataURIData[3]));\n    const bytes = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n\n    data = [bytes];\n  } else {\n    data = [decodeURIComponent(dataURIData[3])];\n  } // Convert to a File?\n\n\n  if (toFile) {\n    return new File(data, opts.name || '', {\n      type: mimeType\n    });\n  }\n\n  return new Blob(data, {\n    type: mimeType\n  });\n}"],"mappings":";;;AAAA,MAAMA,gBAAgB,GAAG,sDAAsD;AAC/E,eAAe,SAASC,aAAa,CAACC,OAAO,EAAEC,IAAI,EAAEC,MAAM,EAAE;EAC3D,IAAIC,IAAI,EAAEC,cAAc;;EAExB;EACA,MAAMC,WAAW,GAAGP,gBAAgB,CAACQ,IAAI,CAACN,OAAO,CAAC,CAAC,CAAC;;EAEpD,MAAMO,QAAQ,GAAG,CAACJ,IAAI,GAAG,CAACC,cAAc,GAAGH,IAAI,CAACM,QAAQ,KAAK,IAAI,GAAGH,cAAc,GAAGC,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,GAAGF,IAAI,GAAG,YAAY;EACjK,IAAIK,IAAI;EAER,IAAIH,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;IAC1B,MAAMI,MAAM,GAAGC,IAAI,CAACC,kBAAkB,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,MAAMO,KAAK,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAACK,MAAM,CAAC;IAE3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,MAAM,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtCH,KAAK,CAACG,CAAC,CAAC,GAAGN,MAAM,CAACO,UAAU,CAACD,CAAC,CAAC;IACjC;IAEAP,IAAI,GAAG,CAACI,KAAK,CAAC;EAChB,CAAC,MAAM;IACLJ,IAAI,GAAG,CAACG,kBAAkB,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7C,CAAC,CAAC;;EAGF,IAAIH,MAAM,EAAE;IACV,OAAO,IAAIe,IAAI,CAACT,IAAI,EAAEP,IAAI,CAACiB,IAAI,IAAI,EAAE,EAAE;MACrCC,IAAI,EAAEZ;IACR,CAAC,CAAC;EACJ;EAEA,OAAO,IAAIa,IAAI,CAACZ,IAAI,EAAE;IACpBW,IAAI,EAAEZ;EACR,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module"}