{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\nimport { Component, cloneElement, h, toChildArray } from 'preact';\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\nfunction linkRef(component, name) {\n  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = c => {\n    component.refs[name] = c;\n  });\n}\nfunction getChildMapping(children) {\n  const out = {};\n  for (let i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      const key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n  return out;\n}\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n  const nextKeysPending = {};\n  let pendingKeys = [];\n  for (const prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n  const childMapping = {};\n  for (const nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {\n        const pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n  for (let i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n  return childMapping;\n}\nconst identity = i => i;\nclass TransitionGroup extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.refs = {};\n    this.state = {\n      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])\n    };\n    this.performAppear = this.performAppear.bind(this);\n    this.performEnter = this.performEnter.bind(this);\n    this.performLeave = this.performLeave.bind(this);\n  }\n  componentWillMount() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToAbortLeave = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  }\n  componentDidMount() {\n    const initialChildMapping = this.state.children;\n    for (const key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        // this.performAppear(getKey(initialChildMapping[key], key));\n        this.performAppear(key);\n      }\n    }\n  }\n  componentWillReceiveProps(nextProps) {\n    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n    const prevChildMapping = this.state.children;\n    this.setState(prevState => ({\n      children: mergeChildMappings(prevState.children, nextChildMapping)\n    }));\n    let key;\n    for (key in nextChildMapping) {\n      if (nextChildMapping.hasOwnProperty(key)) {\n        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n          this.keysToAbortLeave.push(key);\n        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n        }\n      }\n    }\n    for (key in prevChildMapping) {\n      if (prevChildMapping.hasOwnProperty(key)) {\n        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n          this.keysToLeave.push(key);\n        }\n      }\n    }\n  }\n  componentDidUpdate() {\n    const {\n      keysToEnter\n    } = this;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    const {\n      keysToLeave\n    } = this;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  }\n  _finishAbort(key) {\n    const idx = this.keysToAbortLeave.indexOf(key);\n    if (idx !== -1) {\n      this.keysToAbortLeave.splice(idx, 1);\n    }\n  }\n  performAppear(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  }\n  _handleDoneAppearing(key) {\n    const component = this.refs[key];\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n    delete this.currentlyTransitioningKeys[key];\n    this._finishAbort(key);\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  }\n  performEnter(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  }\n  _handleDoneEntering(key) {\n    const component = this.refs[key];\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n    delete this.currentlyTransitioningKeys[key];\n    this._finishAbort(key);\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  }\n  performLeave(key) {\n    // If we should immediately abort this leave function,\n    // don't run the leave transition at all.\n    const idx = this.keysToAbortLeave.indexOf(key);\n    if (idx !== -1) {\n      return;\n    }\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  }\n  _handleDoneLeaving(key) {\n    // If we should immediately abort the leave,\n    // then skip this altogether\n    const idx = this.keysToAbortLeave.indexOf(key);\n    if (idx !== -1) {\n      return;\n    }\n    const component = this.refs[key];\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n    delete this.currentlyTransitioningKeys[key];\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      const children = assign({}, this.state.children);\n      delete children[key];\n      this.setState({\n        children\n      });\n    }\n  }\n  render(_ref, _ref2) {\n    let {\n      childFactory,\n      transitionLeave,\n      transitionName,\n      transitionAppear,\n      transitionEnter,\n      transitionLeaveTimeout,\n      transitionEnterTimeout,\n      transitionAppearTimeout,\n      component,\n      ...props\n    } = _ref;\n    let {\n      children\n    } = _ref2;\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    const childrenToRender = Object.entries(children).map(_ref3 => {\n      let [key, child] = _ref3;\n      if (!child) return undefined;\n      const ref = linkRef(this, key);\n      return cloneElement(childFactory(child), {\n        ref,\n        key\n      });\n    }).filter(Boolean);\n    return h(component, props, childrenToRender);\n  }\n}\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nexport default TransitionGroup;","map":{"version":3,"names":["Component","cloneElement","h","toChildArray","assign","obj","props","Object","getKey","vnode","fallback","_vnode$key","key","linkRef","component","name","cache","_ptgLinkedRefs","c","refs","getChildMapping","children","out","i","length","toString","mergeChildMappings","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","push","childMapping","nextKey","pendingNextKey","identity","TransitionGroup","constructor","context","state","performAppear","bind","performEnter","performLeave","componentWillMount","currentlyTransitioningKeys","keysToAbortLeave","keysToEnter","keysToLeave","componentDidMount","initialChildMapping","componentWillReceiveProps","nextProps","nextChildMapping","prevChildMapping","setState","prevState","hasPrev","hasNext","componentDidUpdate","forEach","_finishAbort","idx","indexOf","splice","componentWillAppear","_handleDoneAppearing","componentDidAppear","currentChildMapping","componentWillEnter","_handleDoneEntering","componentDidEnter","componentWillLeave","_handleDoneLeaving","componentDidLeave","render","_ref","_ref2","childFactory","transitionLeave","transitionName","transitionAppear","transitionEnter","transitionLeaveTimeout","transitionEnterTimeout","transitionAppearTimeout","childrenToRender","entries","map","_ref3","child","undefined","ref","filter","Boolean","defaultProps"],"sources":["/lab/node_modules/@uppy/informer/lib/TransitionGroup.js"],"sourcesContent":["/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\nimport { Component, cloneElement, h, toChildArray } from 'preact';\n\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\n\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\n\nfunction linkRef(component, name) {\n  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = c => {\n    component.refs[name] = c;\n  });\n}\n\nfunction getChildMapping(children) {\n  const out = {};\n\n  for (let i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      const key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n\n  return out;\n}\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  const nextKeysPending = {};\n  let pendingKeys = [];\n\n  for (const prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  const childMapping = {};\n\n  for (const nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {\n        const pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (let i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nconst identity = i => i;\n\nclass TransitionGroup extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.refs = {};\n    this.state = {\n      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])\n    };\n    this.performAppear = this.performAppear.bind(this);\n    this.performEnter = this.performEnter.bind(this);\n    this.performLeave = this.performLeave.bind(this);\n  }\n\n  componentWillMount() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToAbortLeave = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  }\n\n  componentDidMount() {\n    const initialChildMapping = this.state.children;\n\n    for (const key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        // this.performAppear(getKey(initialChildMapping[key], key));\n        this.performAppear(key);\n      }\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n    const prevChildMapping = this.state.children;\n    this.setState(prevState => ({\n      children: mergeChildMappings(prevState.children, nextChildMapping)\n    }));\n    let key;\n\n    for (key in nextChildMapping) {\n      if (nextChildMapping.hasOwnProperty(key)) {\n        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n          this.keysToAbortLeave.push(key);\n        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n        }\n      }\n    }\n\n    for (key in prevChildMapping) {\n      if (prevChildMapping.hasOwnProperty(key)) {\n        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n          this.keysToLeave.push(key);\n        }\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      keysToEnter\n    } = this;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    const {\n      keysToLeave\n    } = this;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  }\n\n  _finishAbort(key) {\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      this.keysToAbortLeave.splice(idx, 1);\n    }\n  }\n\n  performAppear(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  }\n\n  _handleDoneAppearing(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performEnter(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  }\n\n  _handleDoneEntering(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performLeave(key) {\n    // If we should immediately abort this leave function,\n    // don't run the leave transition at all.\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  }\n\n  _handleDoneLeaving(key) {\n    // If we should immediately abort the leave,\n    // then skip this altogether\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    const component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      const children = assign({}, this.state.children);\n      delete children[key];\n      this.setState({\n        children\n      });\n    }\n  }\n\n  render(_ref, _ref2) {\n    let {\n      childFactory,\n      transitionLeave,\n      transitionName,\n      transitionAppear,\n      transitionEnter,\n      transitionLeaveTimeout,\n      transitionEnterTimeout,\n      transitionAppearTimeout,\n      component,\n      ...props\n    } = _ref;\n    let {\n      children\n    } = _ref2;\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    const childrenToRender = Object.entries(children).map(_ref3 => {\n      let [key, child] = _ref3;\n      if (!child) return undefined;\n      const ref = linkRef(this, key);\n      return cloneElement(childFactory(child), {\n        ref,\n        key\n      });\n    }).filter(Boolean);\n    return h(component, props, childrenToRender);\n  }\n\n}\n\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nexport default TransitionGroup;"],"mappings":";AAAA;;AAEA;AACA;AACA;AACA,SAASA,SAAS,EAAEC,YAAY,EAAEC,CAAC,EAAEC,YAAY,QAAQ,QAAQ;AAEjE,SAASC,MAAM,CAACC,GAAG,EAAEC,KAAK,EAAE;EAC1B,OAAOC,MAAM,CAACH,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC;AAClC;AAEA,SAASE,MAAM,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC/B,IAAIC,UAAU;EAEd,OAAO,CAACA,UAAU,GAAGF,KAAK,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACG,GAAG,KAAK,IAAI,GAAGD,UAAU,GAAGD,QAAQ;AAC1F;AAEA,SAASG,OAAO,CAACC,SAAS,EAAEC,IAAI,EAAE;EAChC,MAAMC,KAAK,GAAGF,SAAS,CAACG,cAAc,KAAKH,SAAS,CAACG,cAAc,GAAG,CAAC,CAAC,CAAC;EACzE,OAAOD,KAAK,CAACD,IAAI,CAAC,KAAKC,KAAK,CAACD,IAAI,CAAC,GAAGG,CAAC,IAAI;IACxCJ,SAAS,CAACK,IAAI,CAACJ,IAAI,CAAC,GAAGG,CAAC;EAC1B,CAAC,CAAC;AACJ;AAEA,SAASE,eAAe,CAACC,QAAQ,EAAE;EACjC,MAAMC,GAAG,GAAG,CAAC,CAAC;EAEd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,IAAIF,QAAQ,CAACE,CAAC,CAAC,IAAI,IAAI,EAAE;MACvB,MAAMX,GAAG,GAAGJ,MAAM,CAACa,QAAQ,CAACE,CAAC,CAAC,EAAEA,CAAC,CAACE,QAAQ,CAAC,EAAE,CAAC,CAAC;MAC/CH,GAAG,CAACV,GAAG,CAAC,GAAGS,QAAQ,CAACE,CAAC,CAAC;IACxB;EACF;EAEA,OAAOD,GAAG;AACZ;AAEA,SAASI,kBAAkB,CAACC,IAAI,EAAEC,IAAI,EAAE;EACtCD,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EACjBC,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,MAAMC,cAAc,GAAGjB,GAAG,IAAIgB,IAAI,CAACE,cAAc,CAAClB,GAAG,CAAC,GAAGgB,IAAI,CAAChB,GAAG,CAAC,GAAGe,IAAI,CAACf,GAAG,CAAC,CAAC,CAAC;EAChF;;EAGA,MAAMmB,eAAe,GAAG,CAAC,CAAC;EAC1B,IAAIC,WAAW,GAAG,EAAE;EAEpB,KAAK,MAAMC,OAAO,IAAIN,IAAI,EAAE;IAC1B,IAAIC,IAAI,CAACE,cAAc,CAACG,OAAO,CAAC,EAAE;MAChC,IAAID,WAAW,CAACR,MAAM,EAAE;QACtBO,eAAe,CAACE,OAAO,CAAC,GAAGD,WAAW;QACtCA,WAAW,GAAG,EAAE;MAClB;IACF,CAAC,MAAM;MACLA,WAAW,CAACE,IAAI,CAACD,OAAO,CAAC;IAC3B;EACF;EAEA,MAAME,YAAY,GAAG,CAAC,CAAC;EAEvB,KAAK,MAAMC,OAAO,IAAIR,IAAI,EAAE;IAC1B,IAAIG,eAAe,CAACD,cAAc,CAACM,OAAO,CAAC,EAAE;MAC3C,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,eAAe,CAACK,OAAO,CAAC,CAACZ,MAAM,EAAED,CAAC,EAAE,EAAE;QACxD,MAAMc,cAAc,GAAGN,eAAe,CAACK,OAAO,CAAC,CAACb,CAAC,CAAC;QAClDY,YAAY,CAACJ,eAAe,CAACK,OAAO,CAAC,CAACb,CAAC,CAAC,CAAC,GAAGM,cAAc,CAACQ,cAAc,CAAC;MAC5E;IACF;IAEAF,YAAY,CAACC,OAAO,CAAC,GAAGP,cAAc,CAACO,OAAO,CAAC;EACjD,CAAC,CAAC;;EAGF,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,WAAW,CAACR,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3CY,YAAY,CAACH,WAAW,CAACT,CAAC,CAAC,CAAC,GAAGM,cAAc,CAACG,WAAW,CAACT,CAAC,CAAC,CAAC;EAC/D;EAEA,OAAOY,YAAY;AACrB;AAEA,MAAMG,QAAQ,GAAGf,CAAC,IAAIA,CAAC;AAEvB,MAAMgB,eAAe,SAASvC,SAAS,CAAC;EACtCwC,WAAW,CAAClC,KAAK,EAAEmC,OAAO,EAAE;IAC1B,KAAK,CAACnC,KAAK,EAAEmC,OAAO,CAAC;IACrB,IAAI,CAACtB,IAAI,GAAG,CAAC,CAAC;IACd,IAAI,CAACuB,KAAK,GAAG;MACXrB,QAAQ,EAAED,eAAe,CAACjB,YAAY,CAACA,YAAY,CAAC,IAAI,CAACG,KAAK,CAACe,QAAQ,CAAC,CAAC,IAAI,EAAE;IACjF,CAAC;IACD,IAAI,CAACsB,aAAa,GAAG,IAAI,CAACA,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC;IAClD,IAAI,CAACC,YAAY,GAAG,IAAI,CAACA,YAAY,CAACD,IAAI,CAAC,IAAI,CAAC;IAChD,IAAI,CAACE,YAAY,GAAG,IAAI,CAACA,YAAY,CAACF,IAAI,CAAC,IAAI,CAAC;EAClD;EAEAG,kBAAkB,GAAG;IACnB,IAAI,CAACC,0BAA0B,GAAG,CAAC,CAAC;IACpC,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,WAAW,GAAG,EAAE;EACvB;EAEAC,iBAAiB,GAAG;IAClB,MAAMC,mBAAmB,GAAG,IAAI,CAACX,KAAK,CAACrB,QAAQ;IAE/C,KAAK,MAAMT,GAAG,IAAIyC,mBAAmB,EAAE;MACrC,IAAIA,mBAAmB,CAACzC,GAAG,CAAC,EAAE;QAC5B;QACA,IAAI,CAAC+B,aAAa,CAAC/B,GAAG,CAAC;MACzB;IACF;EACF;EAEA0C,yBAAyB,CAACC,SAAS,EAAE;IACnC,MAAMC,gBAAgB,GAAGpC,eAAe,CAACjB,YAAY,CAACoD,SAAS,CAAClC,QAAQ,CAAC,IAAI,EAAE,CAAC;IAChF,MAAMoC,gBAAgB,GAAG,IAAI,CAACf,KAAK,CAACrB,QAAQ;IAC5C,IAAI,CAACqC,QAAQ,CAACC,SAAS,KAAK;MAC1BtC,QAAQ,EAAEK,kBAAkB,CAACiC,SAAS,CAACtC,QAAQ,EAAEmC,gBAAgB;IACnE,CAAC,CAAC,CAAC;IACH,IAAI5C,GAAG;IAEP,KAAKA,GAAG,IAAI4C,gBAAgB,EAAE;MAC5B,IAAIA,gBAAgB,CAAC1B,cAAc,CAAClB,GAAG,CAAC,EAAE;QACxC,MAAMgD,OAAO,GAAGH,gBAAgB,IAAIA,gBAAgB,CAAC3B,cAAc,CAAClB,GAAG,CAAC,CAAC,CAAC;;QAE1E,IAAI4C,gBAAgB,CAAC5C,GAAG,CAAC,IAAIgD,OAAO,IAAI,IAAI,CAACZ,0BAA0B,CAACpC,GAAG,CAAC,EAAE;UAC5E,IAAI,CAACsC,WAAW,CAAChB,IAAI,CAACtB,GAAG,CAAC;UAC1B,IAAI,CAACqC,gBAAgB,CAACf,IAAI,CAACtB,GAAG,CAAC;QACjC,CAAC,MAAM,IAAI4C,gBAAgB,CAAC5C,GAAG,CAAC,IAAI,CAACgD,OAAO,IAAI,CAAC,IAAI,CAACZ,0BAA0B,CAACpC,GAAG,CAAC,EAAE;UACrF,IAAI,CAACsC,WAAW,CAAChB,IAAI,CAACtB,GAAG,CAAC;QAC5B;MACF;IACF;IAEA,KAAKA,GAAG,IAAI6C,gBAAgB,EAAE;MAC5B,IAAIA,gBAAgB,CAAC3B,cAAc,CAAClB,GAAG,CAAC,EAAE;QACxC,MAAMiD,OAAO,GAAGL,gBAAgB,IAAIA,gBAAgB,CAAC1B,cAAc,CAAClB,GAAG,CAAC;QAExE,IAAI6C,gBAAgB,CAAC7C,GAAG,CAAC,IAAI,CAACiD,OAAO,IAAI,CAAC,IAAI,CAACb,0BAA0B,CAACpC,GAAG,CAAC,EAAE;UAC9E,IAAI,CAACuC,WAAW,CAACjB,IAAI,CAACtB,GAAG,CAAC;QAC5B;MACF;IACF;EACF;EAEAkD,kBAAkB,GAAG;IACnB,MAAM;MACJZ;IACF,CAAC,GAAG,IAAI;IACR,IAAI,CAACA,WAAW,GAAG,EAAE;IACrBA,WAAW,CAACa,OAAO,CAAC,IAAI,CAAClB,YAAY,CAAC;IACtC,MAAM;MACJM;IACF,CAAC,GAAG,IAAI;IACR,IAAI,CAACA,WAAW,GAAG,EAAE;IACrBA,WAAW,CAACY,OAAO,CAAC,IAAI,CAACjB,YAAY,CAAC;EACxC;EAEAkB,YAAY,CAACpD,GAAG,EAAE;IAChB,MAAMqD,GAAG,GAAG,IAAI,CAAChB,gBAAgB,CAACiB,OAAO,CAACtD,GAAG,CAAC;IAE9C,IAAIqD,GAAG,KAAK,CAAC,CAAC,EAAE;MACd,IAAI,CAAChB,gBAAgB,CAACkB,MAAM,CAACF,GAAG,EAAE,CAAC,CAAC;IACtC;EACF;EAEAtB,aAAa,CAAC/B,GAAG,EAAE;IACjB,IAAI,CAACoC,0BAA0B,CAACpC,GAAG,CAAC,GAAG,IAAI;IAC3C,MAAME,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAACsD,mBAAmB,EAAE;MACjCtD,SAAS,CAACsD,mBAAmB,CAAC,IAAI,CAACC,oBAAoB,CAACzB,IAAI,CAAC,IAAI,EAAEhC,GAAG,CAAC,CAAC;IAC1E,CAAC,MAAM;MACL,IAAI,CAACyD,oBAAoB,CAACzD,GAAG,CAAC;IAChC;EACF;EAEAyD,oBAAoB,CAACzD,GAAG,EAAE;IACxB,MAAME,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAACwD,kBAAkB,EAAE;MAChCxD,SAAS,CAACwD,kBAAkB,EAAE;IAChC;IAEA,OAAO,IAAI,CAACtB,0BAA0B,CAACpC,GAAG,CAAC;IAE3C,IAAI,CAACoD,YAAY,CAACpD,GAAG,CAAC;IAEtB,MAAM2D,mBAAmB,GAAGnD,eAAe,CAACjB,YAAY,CAAC,IAAI,CAACG,KAAK,CAACe,QAAQ,CAAC,IAAI,EAAE,CAAC;IAEpF,IAAI,CAACkD,mBAAmB,IAAI,CAACA,mBAAmB,CAACzC,cAAc,CAAClB,GAAG,CAAC,EAAE;MACpE;MACA,IAAI,CAACkC,YAAY,CAAClC,GAAG,CAAC;IACxB;EACF;EAEAiC,YAAY,CAACjC,GAAG,EAAE;IAChB,IAAI,CAACoC,0BAA0B,CAACpC,GAAG,CAAC,GAAG,IAAI;IAC3C,MAAME,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAAC0D,kBAAkB,EAAE;MAChC1D,SAAS,CAAC0D,kBAAkB,CAAC,IAAI,CAACC,mBAAmB,CAAC7B,IAAI,CAAC,IAAI,EAAEhC,GAAG,CAAC,CAAC;IACxE,CAAC,MAAM;MACL,IAAI,CAAC6D,mBAAmB,CAAC7D,GAAG,CAAC;IAC/B;EACF;EAEA6D,mBAAmB,CAAC7D,GAAG,EAAE;IACvB,MAAME,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAAC4D,iBAAiB,EAAE;MAC/B5D,SAAS,CAAC4D,iBAAiB,EAAE;IAC/B;IAEA,OAAO,IAAI,CAAC1B,0BAA0B,CAACpC,GAAG,CAAC;IAE3C,IAAI,CAACoD,YAAY,CAACpD,GAAG,CAAC;IAEtB,MAAM2D,mBAAmB,GAAGnD,eAAe,CAACjB,YAAY,CAAC,IAAI,CAACG,KAAK,CAACe,QAAQ,CAAC,IAAI,EAAE,CAAC;IAEpF,IAAI,CAACkD,mBAAmB,IAAI,CAACA,mBAAmB,CAACzC,cAAc,CAAClB,GAAG,CAAC,EAAE;MACpE;MACA,IAAI,CAACkC,YAAY,CAAClC,GAAG,CAAC;IACxB;EACF;EAEAkC,YAAY,CAAClC,GAAG,EAAE;IAChB;IACA;IACA,MAAMqD,GAAG,GAAG,IAAI,CAAChB,gBAAgB,CAACiB,OAAO,CAACtD,GAAG,CAAC;IAE9C,IAAIqD,GAAG,KAAK,CAAC,CAAC,EAAE;MACd;IACF;IAEA,IAAI,CAACjB,0BAA0B,CAACpC,GAAG,CAAC,GAAG,IAAI;IAC3C,MAAME,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAAC6D,kBAAkB,EAAE;MAChC7D,SAAS,CAAC6D,kBAAkB,CAAC,IAAI,CAACC,kBAAkB,CAAChC,IAAI,CAAC,IAAI,EAAEhC,GAAG,CAAC,CAAC;IACvE,CAAC,MAAM;MACL;MACA;MACA;MACA,IAAI,CAACgE,kBAAkB,CAAChE,GAAG,CAAC;IAC9B;EACF;EAEAgE,kBAAkB,CAAChE,GAAG,EAAE;IACtB;IACA;IACA,MAAMqD,GAAG,GAAG,IAAI,CAAChB,gBAAgB,CAACiB,OAAO,CAACtD,GAAG,CAAC;IAE9C,IAAIqD,GAAG,KAAK,CAAC,CAAC,EAAE;MACd;IACF;IAEA,MAAMnD,SAAS,GAAG,IAAI,CAACK,IAAI,CAACP,GAAG,CAAC;IAEhC,IAAIE,SAAS,CAAC+D,iBAAiB,EAAE;MAC/B/D,SAAS,CAAC+D,iBAAiB,EAAE;IAC/B;IAEA,OAAO,IAAI,CAAC7B,0BAA0B,CAACpC,GAAG,CAAC;IAC3C,MAAM2D,mBAAmB,GAAGnD,eAAe,CAACjB,YAAY,CAAC,IAAI,CAACG,KAAK,CAACe,QAAQ,CAAC,IAAI,EAAE,CAAC;IAEpF,IAAIkD,mBAAmB,IAAIA,mBAAmB,CAACzC,cAAc,CAAClB,GAAG,CAAC,EAAE;MAClE;MACA,IAAI,CAACiC,YAAY,CAACjC,GAAG,CAAC;IACxB,CAAC,MAAM;MACL,MAAMS,QAAQ,GAAGjB,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACsC,KAAK,CAACrB,QAAQ,CAAC;MAChD,OAAOA,QAAQ,CAACT,GAAG,CAAC;MACpB,IAAI,CAAC8C,QAAQ,CAAC;QACZrC;MACF,CAAC,CAAC;IACJ;EACF;EAEAyD,MAAM,CAACC,IAAI,EAAEC,KAAK,EAAE;IAClB,IAAI;MACFC,YAAY;MACZC,eAAe;MACfC,cAAc;MACdC,gBAAgB;MAChBC,eAAe;MACfC,sBAAsB;MACtBC,sBAAsB;MACtBC,uBAAuB;MACvB1E,SAAS;MACT,GAAGR;IACL,CAAC,GAAGyE,IAAI;IACR,IAAI;MACF1D;IACF,CAAC,GAAG2D,KAAK;IACT;IACA;IACA,MAAMS,gBAAgB,GAAGlF,MAAM,CAACmF,OAAO,CAACrE,QAAQ,CAAC,CAACsE,GAAG,CAACC,KAAK,IAAI;MAC7D,IAAI,CAAChF,GAAG,EAAEiF,KAAK,CAAC,GAAGD,KAAK;MACxB,IAAI,CAACC,KAAK,EAAE,OAAOC,SAAS;MAC5B,MAAMC,GAAG,GAAGlF,OAAO,CAAC,IAAI,EAAED,GAAG,CAAC;MAC9B,OAAOX,YAAY,CAACgF,YAAY,CAACY,KAAK,CAAC,EAAE;QACvCE,GAAG;QACHnF;MACF,CAAC,CAAC;IACJ,CAAC,CAAC,CAACoF,MAAM,CAACC,OAAO,CAAC;IAClB,OAAO/F,CAAC,CAACY,SAAS,EAAER,KAAK,EAAEmF,gBAAgB,CAAC;EAC9C;AAEF;AAEAlD,eAAe,CAAC2D,YAAY,GAAG;EAC7BpF,SAAS,EAAE,MAAM;EACjBmE,YAAY,EAAE3C;AAChB,CAAC;AACD,eAAeC,eAAe"},"metadata":{},"sourceType":"module"}